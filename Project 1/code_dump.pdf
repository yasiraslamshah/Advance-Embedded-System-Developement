/* -.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.
* File Name : temperature.c
* Creation Date : 21-03-2019
* Last Modified : Wed 31 March 2019 00:02:56 PM MDT
* Created By : Harsimransingh and Yasir Shah
* Description: Source file contataining function defintion for temperature sensor read write functions
* 
* Functions:
*           -temp_main() function is first initializes the I2C bus then calls the read_temperature function. 
*           -Read_Temperature() read function to read data from TMA102 sensor in C,K,F
*           -temperature_function() temperature pthread spawned calls this function which initalises the temperature queue intializes the timer parameters and starts a timer which logs temperature value periodically
*           -temperature_handler() Temperature timer handler which logs the temperature periodically by addding new temperature value to the temp queue.
*           -temp_test() used for intial testing of the sensor
*           -temp_state() for knowing the current state
*           -Write_pointer_reg()
*           -Read_Tlow()
*           -Read_Thigh()
*           -Read_Resolution()
*           -Read_Fault_Bits()
*           -Set_ShutDown()
*           -Clear_ShutDown()
*           -Set_EM()
*           -Set_Conversion()
*           -Write_Configuration()

* References:
*           -http://www.ti.com/lit/ds/symlink/tmp102.pdf
*           -https://www.sparkfun.com/products/13314  
*           
_._._._._._._._._._._._._._._._._._._._._.*/



/*user defined library*/
#include "temperature.h"

mqd_t temp_discriptor;

void *temperature_function(void *arg)
{
  struct mq_attr attribute;
  attribute.mq_maxmsg = 10;
  attribute.mq_msgsize = sizeof(msg_struct);
  attribute.mq_flags = 0;
  attribute.mq_curmsgs = 0;

  /*create a queue for transferring temperature value to logger task*/
  temp_discriptor = mq_open ("/temp_queue", O_RDWR | O_CREAT, 0666, &attribute);
  if (temp_discriptor < 0)
  {
    printf("temperature message queue error\n");
  }
  else
  {
    printf("temperature message queue created successfully\n");
  }

  timer_t timer_id;
  thread_struct *light_thread = (thread_struct *)arg;
  struct sigevent sev;
  memset(&sev,0,sizeof(struct sigevent));
  struct itimerspec trigger;
  memset(&trigger,0,sizeof(struct itimerspec));

/*set timer event characteristics*/
  sev.sigev_notify = SIGEV_THREAD;
  sev.sigev_notify_function = &temperature_handler;
  sev.sigev_value.sival_ptr = light_thread->log_file;
  timer_create(CLOCK_REALTIME, &sev, &timer_id);

/*set timer capabilities*/
  trigger.it_value.tv_sec=1;
  trigger.it_value.tv_nsec=0;
  trigger.it_interval.tv_sec=1;
  trigger.it_interval.tv_nsec=0;
  /*enable timer*/
  timer_settime(timer_id,0, &trigger, NULL);
  /*wait for the exit flag*/
  while(exit_flag != 1);
  timer_delete(timer_id);
  /*close the queue before exit*/
  mq_close(temp_discriptor);
}

void temperature_handler(union sigval sv)
{
  /*For heartbeat implementation*/
  pthread_cond_broadcast(&temp_thread_cond);
  char *file_name = sv.sival_ptr;
  FILE *file_ptr;
  float temp_value;
  static int error_status;
  /*read temperature periodically*/
  int result = temp_main(&temp_value, UNIT);
  if(result == EXIT_FAILURE)
  { 
    error_status++;
    /*condition when sensor is plugged out*/
    if(error_status == 1)
    {
      int light_led_status = 1;
      /*turn an led on to indicate sensor failure*/
      led_control(RED,light_led_status);
      printf("\nTemperature Sensor disconnected!\n");
      msg_struct *msg = (msg_struct *)malloc(sizeof(msg_struct));
      memset(msg->thread_name,'\0',sizeof(msg->thread_name));
      memcpy(msg->thread_name,"temperature",strlen("temperature"));
      memset(msg->level,'\0',sizeof(msg->level));
      memcpy(msg->level,"ALERT",strlen("ALERT"));
      msg->unit = '\0';
      /*send alert message to the logger task*/
      if(mq_send(temp_discriptor,(char *)msg,sizeof(msg_struct),0) < 0)
      {
        printf("Error sending to temperature queue\n");
        mq_close(temp_discriptor);
      }
      else
      {
        temperature_flag = 1;
      }
    }
  }
  /*condition is sensor is read successfully*/
  else if(result == EXIT_SUCCESS)
  {
    if(error_status != 0)
    {
      int light_led_status = 0;
      led_control(RED,light_led_status);
    }
    error_status = 0;
    msg_struct *msg = (msg_struct *)malloc(sizeof(msg_struct));
    memset(msg->thread_name,'\0',sizeof(msg->thread_name));
    memcpy(msg->thread_name,"temperature",strlen("temperature"));
    msg->sensor_value = temp_value;
    memset(msg->level,'\0',sizeof(msg->level));
    memcpy(msg->level,"DATA",strlen("DATA"));
    memset(msg->state,'\0',sizeof(msg->state));
    temp_state(temp_value, msg, UNIT);
    if(UNIT == 1)
      msg->unit = 'C';
    else if(UNIT == 2)
      msg->unit = 'K';
    else if(UNIT == 3)
      msg->unit = 'F';
    printf("Temperature value:%0.2f%c\tState:%s\n",msg->sensor_value,msg->unit,msg->state);
    /*send data to the logger task*/
    if(mq_send(temp_discriptor,(char *)msg,sizeof(msg_struct),0) < 0)
    {
      printf("Error sending to temperature queue\n");
      mq_close(temp_discriptor);
    }
    else
    {
      temperature_flag = 1;
    }
  }
  /*print error if sensor is disconnected*/
  if(error_status > 0 && error_status%2 == 0)
  {
    printf("\ntemperature Sensor disconnected\n");
  }
}

int temp_main(float *temp_value, int unit)
{
  /*lock mutex for synchronised I2C access*/
  pthread_mutex_lock(&bus_lock);
  /*intialize the I2C bus*/
  int result=I2C_init(&file,1);
  if(result == EXIT_FAILURE)
  {
    perror("\nError: Sensor Initialization Failed!\n");
    pthread_mutex_unlock(&bus_lock);
    return EXIT_FAILURE;
  }
  result = Read_Temperature(file,unit,temp_value);
  if(result == EXIT_FAILURE)
  {
    perror("\nError: Sensor Reading Failed!\n");
    pthread_mutex_unlock(&bus_lock);
    return EXIT_FAILURE;
  }
  /*return the I2C bus mutex*/
  pthread_mutex_unlock(&bus_lock);
  return EXIT_SUCCESS;
}

//read function to read data from TMA102 sensor in C,K,F
int Read_Temperature(int file,int unit, float *temp_value)
{

  int result=I2C_Write_Byte(file,TMPSensor_Register);
  if(result == EXIT_FAILURE)
  {
    perror("\nError: Failed to Write!\n");
    return EXIT_FAILURE;
  }
  usleep(500);
  char buf[1];
  result=I2C_Read_Word(file,buf);
  if(result == EXIT_FAILURE)
  {
    perror("\nError: Failed to Write!\n");
    return EXIT_FAILURE;
  } 
	
  int temperature;
	temperature = ((buf[0]) << 8) | (buf[1]);
	temperature >>= 4;
  
  /*correcting the signed bit*/
	if (temperature & (1 << 11))
  {
    temperature = temperature | Minus_Correction;
  }
  float final_temperature = temperature * Celsius ;
  
  if(unit == 1)
  {
    final_temperature= temperature * Celsius;
    *temp_value = final_temperature;
  }
  else if(unit == 2)
  {
    float final_temperature_F = Temp_Conversion(final_temperature,unit);
    *temp_value = final_temperature_F;

  }
  else if(unit == 3)
  {
    float final_temperature_K = Temp_Conversion(final_temperature,unit);
    *temp_value = final_temperature_K;
 }
  return EXIT_SUCCESS;
}

void temp_state(float temp_value, msg_struct *msg, int unit)
{
  if(unit == 1)
  {
    if(temp_value > CELSIUS_THRESHOLD)
    {
      memcpy(msg->state,"hot\0",strlen("hot\0"));
    }
    else
    {
      memcpy(msg->state,"cool\0",strlen("cool\0"));
    }
  }
  else if(unit ==2)
  {
    if(temp_value > KELVIN_THRESHOLD)
    {
      memcpy(msg->state,"hot\0",strlen("hot\0"));
    }
    else
    {
      memcpy(msg->state,"cool\0",strlen("cool\0"));
    }
  }
  else if(unit ==3)
  {
    if(temp_value > FARHENIET_THRESHOLD)
    {
      memcpy(msg->state,"hot\0",strlen("hot\0"));
    }
    else
    {
      memcpy(msg->state,"cool\0",strlen("cool\0"));
    }
  }
}

int Write_Pointer_Reg(int file, uint8_t value)
{
	int result = I2C_Write_Byte(file,value);
  	if(result == EXIT_FAILURE)
  	{
    		perror("\nError: Failed to Write to Pointer!\n");
    		return EXIT_FAILURE;
  	}
}

int Read_TLow(int file)
{
  int val = 0;
  char buffer[1];	
  int result = I2C_Write_Byte(file,TMPSensor_TLow);
  if(result == EXIT_FAILURE)
  {
    perror("\nError: Failed to Write!\n");
    return EXIT_FAILURE;
  }
  result = I2C_Read_Byte_Data(file,buffer);
  if(result == EXIT_FAILURE)
  {
    perror("\nError: Failed to Write!\n");
    return EXIT_FAILURE;
  }
  int temperature=0;
  Write_Configuration(file, val);
  float temp = 0.0;

  if(val == 1)
  {
  	temperature = ((buffer[0]) << 8) | (buffer[1]);
  	temperature >>= 3;
	temp = temperature * Celsius;
  }
  else 
  {
	temperature = ((buffer[0]) << 8) | (buffer[1]);
  	temperature >>= 4; 
  	temp = temperature * Celsius ;
  }	
  printf("Read Value TLow is %f ",temp); 
 
  return EXIT_SUCCESS;
}

int Read_THigh(int file)
{
  int val = 0;
  int result = I2C_Write_Byte(file,TMPSensor_THigh);
  if(result == EXIT_FAILURE)
  {
    perror("\nError: Failed to Write!\n");
    return EXIT_FAILURE;
  }
  uint8_t buffer[1];
  result = I2C_Read_Word(file,buffer);
  if(result == EXIT_FAILURE)
  {
    perror("\nError: Failed to Write!\n");
    return EXIT_FAILURE;
  }
  float temp= 0.0;
  int temperature = 0;
  Write_Configuration(file, val);
  if(val == 1)
  {
  	temperature = ((buffer[0]) << 8) | (buffer[1]);
  	temperature >>= 3; 
 	temp = temperature * Celsius ;
  }
  else 
  {
	temperature = ((buffer[0]) << 8) | (buffer[1]);
  	temperature >>= 4; 	
  	temp = temperature * Celsius ;
  }	
  printf("Read Value THigh is %f ",temp);
  return EXIT_SUCCESS;
}

int Read_Resolution(int file)
{
  uint16_t value = Resolution;
  int result=I2C_Write_Bytes(file,&value);
  if(result == EXIT_FAILURE)
  {
    perror("\nError: Failed to Write!\n");
    return EXIT_FAILURE;
  }
  char buffer[1];
  result = I2C_Read_Word(file,buffer);
  if(result == EXIT_FAILURE)
  {
    perror("\nError: Failed to Read!\n");
    return EXIT_FAILURE;
  }
  unsigned char MSB =buffer[0];
  MSB = MSB & 0b01100000;
  if(MSB == 0x13)
  {
	printf("Resolution at 12 ");
  }
  else 
  {
 	printf("Resolutiion at 13 ");
  }
  return EXIT_SUCCESS;
}

int Read_Fault_Bits(int file)
{
  uint16_t value = Fault_Bits_4;	
 
  int result=I2C_Write_Bytes(file,&value);
  if(result == EXIT_FAILURE)
  {
    perror("\nError: Failed to Write!\n");
    return EXIT_FAILURE;
  }
  char buffer[1];
  result = I2C_Read_Word(file,buffer);
  if(result == EXIT_FAILURE)
  {
    perror("\nError: Failed to Read!\n");
    return EXIT_FAILURE;
  }
  unsigned char MSB =buffer[0];
  unsigned char LSB= buffer[1];
  //MSB = MSB & 0b01111000;
  if(MSB ==0x13)
  {
	printf("Fault Bits 4 ");
  }
  else 
  {
 	printf("Fault Bits less than 4 ");
  }
  return EXIT_SUCCESS;
}
int Clear_ShutDown(int file)
{
  uint16_t value =ShutDown_Clear;	
  int result=Write_Pointer_Reg(file,value);
  if(result == EXIT_FAILURE)
  {
    perror("\nError: Failed to Write!\n");
    return EXIT_FAILURE;
  }
  char buffer[1];
  result = I2C_Read_Word(file,buffer);
  if(result == EXIT_FAILURE)
  {
    perror("\nError: Failed to Read!\n");
    return EXIT_FAILURE;
  }
  unsigned char MSB =buffer[0];
  //MSB = MSB & 0b011000001;
  
  if(MSB == 0x60)
  {
	printf("ShutDown Mode Enable ");
  }
  else 
  {
 	printf("ShutDown Mode Disable ");
  }
  return EXIT_SUCCESS;
}
int Set_ShutDown(int file)
{
  uint16_t value =ShutDown_Set;	
  int result=Write_Pointer_Reg(file,value);
  if(result == EXIT_FAILURE)
  {
    perror("\nError: Failed to Write!\n");
    return EXIT_FAILURE;
  }
  char buffer[1];
  result = I2C_Read_Word(file,buffer);
  if(result == EXIT_FAILURE)
  {
    perror("\nError: Failed to Read!\n");
    return EXIT_FAILURE;
  }
  unsigned char MSB =buffer[0];
  
  if(MSB == 0x13)
  {
	printf("ShutDown Mode Enable ");
  }
  else 
  {
 	printf("ShutDown Mode Disable ");
  }
  return EXIT_SUCCESS;
}
int Set_EM(int file)
{
  uint16_t value =EM_Set;	
  int result=Write_Pointer_Reg(file,value);
  if(result == EXIT_FAILURE)
  {
    perror("\nError: Failed to Write!\n");
    return EXIT_FAILURE;
  }
  char buffer[1];
  result = I2C_Read_Word(file,buffer);
  if(result == EXIT_FAILURE)
  {
    perror("\nError: Failed to Read!\n");
    return EXIT_FAILURE;
  }
  unsigned char LSB =buffer[1];
  
  if(LSB ==0x10)
  {
	printf("Extended Mode 13 Bit ");
  }
  else 
  {
 	printf("Extended Mode 12 Bit ");
  }
  return EXIT_SUCCESS;
}
int Set_Conversion(int file)
{
  uint16_t value =TMPSensor_Conversion_8;	
  int result=Write_Pointer_Reg(file,value);
  if(result == EXIT_FAILURE)
  {
    perror("\nError: Failed to Write_Convert!\n");
    return EXIT_FAILURE;
  }
  char buffer[1];
  result = I2C_Read_Word(file,buffer);
  if(result == EXIT_FAILURE)
  {
    perror("\nError: Failed to Read_Convert!\n");
    return EXIT_FAILURE;
  }
  unsigned char LSB =buffer[1];
  
  if(LSB == 0x40)
  {
  	printf("1Hz Frequency set! ");
  }
  else if(LSB == 0xc0)
  {
  	printf("8Hz Frequency set! ");
  }
  else
  {
  	printf("4Hz Frequency Set by Default ");
  }
  return EXIT_SUCCESS;
}

int Write_Configuration(int file, int val)
{
  uint16_t value =TMPSensor_Configuration;	
  int result=Write_Pointer_Reg(file,value);
  if(result == EXIT_FAILURE)
  {
    perror("\nError: Failed to Write!\n");
    return EXIT_FAILURE;
  }
  char buffer[1];
  result = I2C_Read_Word(file,buffer);
  if(result == EXIT_FAILURE)
  {
    perror("\nError: Failed to Read!\n");
    return EXIT_FAILURE;
  }
  unsigned char LSB =buffer[1];
  LSB = LSB & Mask;
  if(LSB ==0x10)
  {
  	val =1;
  }
  else val =0;

  return EXIT_SUCCESS;
}
/* -.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.
* File Name : light.c
* Creation Date : 20-03-2019
* Last Modified : Wed 31 March 2019 00:09:00 PM MDT
* Created By : Harsimransingh and Yasir Shah
* Description: header file to contatainging function declaration for light sensors
* 
* Functions:
*           - Light_main() function is first initializes the I2C bus then calls the Read_Data function. 
*           - Read_Data() it calculates the lux value based on channel 1 and channel 2 values depending on the datasheet
*           - Read_Light_Sensor() it calculates the lux value based on channel 1 and channel 2 values depending on the datasheet 
*           - Turn_on_Light_sensor() turns the sensor on
*           - Check_PowerUp() to test if it successfully powers up the sensor
*           - light_function() light pthread spawned calls this function
*           - light_handler() light timer handler which logs the light value periodically by addding new light value to the temp queue.
*           - light_test() function to test the light sensor during initial startup
* References:
*           -https://www.broadcom.com/products/optical-sensors/ambient-light-photo-sensors/apds-9301
*           -https://learn.sparkfun.com/tutorials/apds-9301-sensor-hookup-guide/all         
_._._._._._._._._._._._._._._._._._._._._.*/

#include "light.h"


int file;
mqd_t ser_discriptor;


void *light_function(void *arg)
{
  struct mq_attr attribute;
  attribute.mq_maxmsg = 10;
  attribute.mq_msgsize = sizeof(msg_struct);
  attribute.mq_flags = 0;
  attribute.mq_curmsgs = 0;

  /*create a queue for transferring light value to logger task*/
  ser_discriptor = mq_open ("/light_queue", O_RDWR | O_CREAT, 0666, &attribute);
  if (ser_discriptor < 0)
  {
    printf("light message queue error\n");
  }
  else
  {
    printf("light message queue created successfully\n");
  }

  timer_t timer_id;
  thread_struct *light_thread = (thread_struct *)arg;
  struct sigevent sev;
  memset(&sev,0,sizeof(struct sigevent));
  struct itimerspec trigger;
  memset(&trigger,0,sizeof(struct itimerspec));

/*set timer event characteristics*/
  sev.sigev_notify = SIGEV_THREAD;
  sev.sigev_notify_function = &light_handler;
  sev.sigev_value.sival_ptr = light_thread->log_file;
  timer_create(CLOCK_REALTIME, &sev, &timer_id);

/*set timer capabilities*/
  trigger.it_value.tv_sec=2;
  trigger.it_value.tv_nsec=0;
  trigger.it_interval.tv_sec=2;
  trigger.it_interval.tv_nsec=0;
  /*enable timer*/
  timer_settime(timer_id,0, &trigger, NULL);
  /*wait for the exit flag*/
  while(exit_flag != 1);
  timer_delete(timer_id);
  /*close the queue before exit*/
  mq_close(ser_discriptor);
}

void light_handler(union sigval sv)
{
  /*For heartbeat implementation*/
  pthread_cond_broadcast(&light_thread_cond);
  static int i;
  char *file_name = sv.sival_ptr;
  FILE *file_ptr;
  float light_value = 0;
  static int error_status;
  /*read temperature periodically*/
  int result = Light_main(&light_value);
  if(result == EXIT_FAILURE)
  {
    error_status++;
    /*condition when sensor is plugged out*/
    if(error_status == 1)
    {
      int light_led_status = 1;
      /*turn an led on to indicate sensor failure*/
      led_control(GREEN,light_led_status);
      printf("\nlight Sensor Disconnected\n");
      msg_struct *msg = (msg_struct *)malloc(sizeof(msg_struct));
      memset(msg->thread_name,'\0',sizeof(msg->thread_name));
      memcpy(msg->thread_name,"light",strlen("light"));
      memset(msg->level,'\0',sizeof(msg->level));
      msg->unit = '\0';
      /*send alert message to the logger task*/
      if(mq_send(ser_discriptor,(char *)msg,sizeof(msg_struct),0) < 0)
      {
        printf("Error sending to light queue\n");
        mq_close(ser_discriptor);
      }
      else
      {
        light_flag = 1;
      }
    }
  }
  /*condition is sensor is read successfully*/
  else if(result == EXIT_SUCCESS)
  {
    if(error_status != 0)
    {
      int light_led_status = 0;
      led_control(GREEN,light_led_status);
    }
    error_status = 0;
    msg_struct *msg = (msg_struct *)malloc(sizeof(msg_struct));
    memset(msg->thread_name,'\0',sizeof(msg->thread_name));
    memcpy(msg->thread_name,"light",strlen("light"));
    msg->sensor_value = light_value;
    memset(msg->level,'\0',sizeof(msg->level));
    memcpy(msg->level,"DATA",strlen("DATA"));
    msg->unit = 'L';
    memset(msg->state,'\0',sizeof(msg->state));
    light_state(light_value,msg); 
    printf("Light value is %0.2f%c\t\tState:%s\n\n",msg->sensor_value,msg->unit,msg->state);
    /*send light sensor value to light queue*/
    if(mq_send(ser_discriptor,(char *)msg,sizeof(msg_struct),0) < 0)
    {
      printf("Error sending to light queue\n");
      mq_close(ser_discriptor);
    }
    else
    {
      light_flag = 1;
    }
  }
  /*print error if sensor is disconnected*/
  if((error_status > 0))
  {
    printf("\nLight Sensor disconnected\n");
  }
}

int Light_main(float *light_value)
{
  /*lock mutex for synchronised I2C access*/
  pthread_mutex_lock(&bus_lock); 
  /*intialize the I2C bus*/
  int result = I2C_init(&file,2);
  if(result == EXIT_FAILURE)
  {
    perror("\nError: Sensor Initialization Failed!\n");
    pthread_mutex_unlock(&bus_lock);
    return EXIT_FAILURE;
  }
  result = Turn_on_Light_sensor(file);
  if(result == EXIT_FAILURE)
  {
    perror("\nError: SensorII Reading Failed!\n");
    pthread_mutex_unlock(&bus_lock);
    return EXIT_FAILURE;
  }
  
  result = Check_PowerUp(file);
  if(result == EXIT_FAILURE)
  {
    perror("\nError: SensorII Reading Failed!\n");
    pthread_mutex_unlock(&bus_lock);
    return EXIT_FAILURE;
  }
  uint8_t SensorID;
  result = Read_Sensor_ID(file,&SensorID);
  if(result == EXIT_FAILURE)
  {
    perror("\nError: SensorII Reading Failed!\n");
    return EXIT_FAILURE;
  }
  result =Read_Light_Sensor(file, light_value);
  if(result == EXIT_FAILURE)
  {
    perror("\nError: SensorII Reading Failed!\n");
    pthread_mutex_unlock(&bus_lock);
    return EXIT_FAILURE;
  }
  /*return the I2C bus mutex*/
  pthread_mutex_unlock(&bus_lock); 
  return EXIT_SUCCESS;

}

uint16_t Read_Data(int file, int flag)
{
  uint8_t LSB,MSB;
  uint16_t Final;
  uint8_t address;
  if(flag == 1)
  {
    address =Command_Control | Data_Low0;
  }
  else if(flag ==2)
  {
    address =Command_Control | Data_Low1;
  }
  
  int result = I2C_Write_Byte(file,address);
  if(result == EXIT_FAILURE)
  {
    perror("\nError: SensorII Reading Failed!\n");
    return EXIT_FAILURE;
  }
  result = I2C_Read_Byte_Data(file,&LSB);
  if(result == EXIT_FAILURE)
  {
    perror("\nError: SensorII Reading Failed!\n");
    return EXIT_FAILURE;
  }
   if(flag == 1)
  {
    address =Command_Control | Data_High0;
  }
  else if(flag ==2)
  {
    address =Command_Control | Data_High1;
  }
  result = I2C_Write_Byte(file,address);
  if(result == EXIT_FAILURE)
  {
    perror("\nError: SensorII Reading Failed!\n");
    return EXIT_FAILURE;
  }
  result = I2C_Read_Byte_Data(file,&MSB);
  if(result == EXIT_FAILURE)
  {
 //   printf("\nError: SensorII Reading Failed!\n");
    return EXIT_FAILURE;
  }
  Final = (MSB<<8)|(LSB);
  //printf("\nValue is %d\n",Final);
  return Final;
}

//function to read lux values
int Read_Light_Sensor(int file, float *light_value)
{ float Lux_Value = 0;
  float data0 =(float)Read_Data(file,1);
  float data1 =(float)Read_Data(file,2);  
	if(data0 == 0)
	{
		perror("Error:Process Failed!");
		return EXIT_FAILURE;
	}
	
	float ADC= data1/data0;
  float power = pow(ADC,1.4);
	if(0 < ADC < 0.50)
	{
		Lux_Value = (0.0304 * data0) - (0.062 * data0 * power);
	}
	else if(0.50 < ADC < 0.61)
	{
		Lux_Value = (0.0224 * data0) - (0.031 * data1);
	}
	else if(0.61 < ADC < 0.80)
	{
		Lux_Value = (0.0128 * data0) - (0.0153 * data1);
	}
	else if(0.80 < ADC < 1.30)
	{
		Lux_Value = (0.00146 * data0) - (0.00112 * data1);
	}
	else
	{
		Lux_Value = 0;
	}
  *light_value = Lux_Value;
return EXIT_SUCCESS;
}

//function to check sensor is working by power up
int Turn_on_Light_sensor(int file)
{
  int result = write_control(file,Power_Up);
  if(result == EXIT_FAILURE)
  {
//    printf("\nError: Sensor Initialization Failed!\n");
    return EXIT_FAILURE;
  }
  result = write_timing(file,0x12);
  if(result == EXIT_FAILURE)
  {
//    printf("\nError: Sensor Initialization Failed!\n");
    return EXIT_FAILURE;
  }
}

//function to see if power up is working
int Check_PowerUp(int file)
{
  int result = I2C_Write_Byte(file,Command_Control);
  if(result == EXIT_FAILURE)
  {
//    printf("\nError: Sensor Initialization Failed!\n");
    return EXIT_FAILURE;
  }
  uint8_t buf[1];
  result = I2C_Read_Word(file,buf);
  if(result == EXIT_FAILURE)
  {
    return EXIT_FAILURE;
  }
  return EXIT_SUCCESS;
}

int Read_Sensor_ID(int file,uint8_t *data)
{
  uint8_t value = Command_Control | Sensor_ID;
  int result = I2C_Write_Byte(file,value);
  if(result == EXIT_FAILURE)
  {
    perror("\nError: Sensor_ID Write Failed!\n");
    return EXIT_FAILURE;
  }
  result = I2C_Read_Byte_Data(file,data);
  if(result == EXIT_FAILURE)
  {
    perror("\nError: Sensor_ID Write Failed!\n");
    return EXIT_FAILURE;
  }
  if(*data == 0x50)
  {
    perror("\nSensorID Read Successfull!\n");
    return EXIT_SUCCESS;
  }
  return EXIT_SUCCESS;
}

int Read_Interrupt(int file)
{
  uint8_t value = Command_Control | Threshold_LL;
  int data[3];
  uint8_t *dat;
  
  int result = I2C_Read_Byte_Data(file,&value);
  if(result == EXIT_FAILURE)
  {
    perror("\nError: Sensor_ID 2Write Failed!\n");
    return EXIT_FAILURE;
  }
  //perror("\nValue in read%d", value); 
  value = Command_Control | Threshold_LH;
  result = I2C_Read_Byte_Data(file,&value);
  if(result == EXIT_FAILURE)
  {
    perror("\nError: Sensor_ID 2Write Failed!\n");
    return EXIT_FAILURE;
  }
  //printf("\nValue in read%d", value); 


  value = Command_Control | Threshold_HL;
  result = I2C_Read_Byte_Data(file,&value);
  if(result == EXIT_FAILURE)
  {
    perror("\nError: Sensor_ID 2Write Failed!\n");
    return EXIT_FAILURE;
  }
  //printf("\nValue in read%d", value); 

  
  value = Command_Control | Threshold_HH;
  result = I2C_Read_Byte_Data(file,&value);
  if(result == EXIT_FAILURE)
  {
    //printf("\nError: Sensor_ID 2Write Failed!\n");
    return EXIT_FAILURE;
  }
  //printf("\nValue in read%d", value); 
  return EXIT_SUCCESS;
}

int Write_Interrupt(int file, uint8_t *in_value)
{
  uint8_t value = Command_Control | Threshold_LL;
  int data[3];
  
  int result = I2C_Write_Byte(file,value);
  if(result == EXIT_FAILURE)
  {
  //  printf("\nError: Sensor_ID Write Failed!\n");
    return EXIT_FAILURE;
  }
  data[0]=0x01;	
  result = I2C_Write_Byte(file,data[0]);
  

  value = Command_Control | Threshold_LH;
  result = I2C_Write_Byte(file,value);
  if(result == EXIT_FAILURE)
  {
    printf("\nError: Sensor_ID Write Failed!\n");
    return EXIT_FAILURE;
  }
  data[1]=0x02;	
  result = I2C_Write_Byte(file,data[1]);
  

  value = Command_Control | Threshold_HL;
  result = I2C_Write_Byte(file,value);
  if(result == EXIT_FAILURE)
  {
    printf("\nError: Sensor_ID Write Failed!\n");
    return EXIT_FAILURE;
  }
  data[2]=0x03;	
  result = I2C_Write_Byte(file,data[2]);
 
  value = Command_Control | Threshold_HH;
  result = I2C_Write_Byte(file,value);
  if(result == EXIT_FAILURE)
  {
    printf("\nError: Sensor_ID Write Failed!\n");
    return EXIT_FAILURE;
  }
  data[3]=0x04;	
  result = I2C_Write_Byte(file,data[3]);  
  //printf("\nData write is %d %d %d %d \n",data[0],data[1],data[2],data[3]);
  return EXIT_SUCCESS;
}

int Disable_Interrupt_Control_Register(int file)
{
  uint8_t value = Command_Control | Interrupt_Control_reg_Disable;
  int result = I2C_Write_Byte(file,value);
  if(result == EXIT_FAILURE)
  {
    //printf("\nError: Interrupt disable Failed!\n");
    return EXIT_FAILURE;
  }
  value =0x23;
  result=I2C_Write_Byte(file,value);
  if(result == EXIT_FAILURE)
  {
    //printf("\nError: Interrupt Enable Failed!\n");
    return EXIT_FAILURE;
  }

  int8_t data;
  result = I2C_Read_Byte_Data(file,&data);
  if(result == EXIT_FAILURE)
  {
    //printf("\nError: Interrupt Disable Read Failed!\n");
    return EXIT_FAILURE;
  }
  //printf("\nRead Inter_Dis: %d %x\n",data,data);
  return EXIT_SUCCESS;
}

void light_state(float LUX, msg_struct *msg)
{
	if(LUX > LIGHT_THRESHOLD)
	{
    memcpy(msg->state,"light\0",strlen("light\0"));
	}
	else
  {
    memcpy(msg->state,"dark\0",strlen("dark\0"));
  }	
}

int Enable_Interrupt_Control_Register(int file)
{
  uint8_t value = Command_Control | Interrupt_Control_reg_Enable;
  int result = I2C_Write_Byte(file,value);
  if(result == EXIT_FAILURE)
  {
    //printf("\nError: Interrupt Enable Failed!\n");
    return EXIT_FAILURE;
  }
  value =0x23;
  result=I2C_Write_Byte(file,value);
  if(result == EXIT_FAILURE)
  {
    //printf("\nError: Interrupt Enable Failed!\n");
    return EXIT_FAILURE;
  }

  uint8_t data=0;
  result = I2C_Read_Byte_Data(file,&data);
  if(result == EXIT_FAILURE)
  {
    //printf("\nError: Interrupt Disable Failed!\n");
    return EXIT_FAILURE;
  }
  return EXIT_SUCCESS;

}


#include "user_led.h"

void led_control(int led_color, int status)
{
	FILE* file_ptr;
	if (status != OFF && status != ON)
	{
		printf("\nINCORRECT LED STATUS\n");
	}
  if (led_color > GREEN && led_color < BLUE)
	{
		printf("INCORRECT LED NUMBER\n");
		exit(-1);
	}
  if(led_color == BLUE)
  {
			file_ptr = fopen("/sys/class/gpio/gpio53/value", "w");
			fprintf(file_ptr,"%i",status);
  }
  else if(led_color == RED)
  {
			file_ptr = fopen("/sys/class/gpio/gpio54/value", "w");
			fprintf(file_ptr,"%i",status);
  }
  else if(led_color == GREEN)
  {
			file_ptr = fopen("/sys/class/gpio/gpio55/value", "w");
			fprintf(file_ptr,"%i",status);
  }
	fclose(file_ptr);
}

#include "logger.h"
#include "i2c.h"
#include "temperature.h"
#include "light.h"

//init function to define the 2c path and allocate buses
int I2C_init(int *file,uint8_t sensor)
{
	int Slave_Address;	
	char *filename= "/dev/i2c-2";
	int temp_file;	
	temp_file=open(filename,O_RDWR);
	*file = temp_file;
  	if(temp_file < 0)
	{
		perror("Error :Cant Open File\n");
		return EXIT_FAILURE;  
	}
	
	if(sensor==Temper)
	{
		Slave_Address  = 0x48;
  }
	else if(sensor==Light)
	{	
		Slave_Address = 0x39;
	}
	if(ioctl(temp_file,I2C_SLAVE,Slave_Address)<0)
	{
		perror("Error:IOCTL Failed!\n");
		return EXIT_FAILURE;
	}
	return EXIT_SUCCESS;
}

//write control function to write to the control registers
uint8_t write_control(int file, uint8_t data)
{
  uint8_t value = Command_Control | Command_Reg;
  int result = I2C_Write_Byte(file,value);
  if(result == EXIT_FAILURE)
  {
    perror("\nError: Sensor Initialization Failed!\n");
    return EXIT_FAILURE;
  } 
  result = I2C_Write_Byte(file,data);
  if(result == EXIT_FAILURE)
  {
    perror("\nError: Sensor Initialization Failed!\n");
    return EXIT_FAILURE;
  }
  return EXIT_SUCCESS;
}

//write timing function to write to the timing registers
uint8_t write_timing(int file, uint8_t data)
{
  uint8_t value = Command_Control | Timing_Reg;
  int result = I2C_Write_Byte(file,value);
  if(result == EXIT_FAILURE)
  {
    perror("\nError: Sensor Initialization Failed!\n");
    return EXIT_FAILURE;
  } 
  result = I2C_Write_Byte(file,data);
  if(result == EXIT_FAILURE)
  {
    perror("\nError: Sensor Initialization Failed!\n");
    return EXIT_FAILURE;
  }
  return EXIT_SUCCESS;
}

//temperature conversion function to change fro Celsius
//Klevina and Farenheit Units as per User Demand
float Temp_Conversion(float temp, int unit)
{
  if(temp == 0)
  {
    return EXIT_FAILURE;
  }
  float temperature;
  if(unit == 2)
  {
    temperature = (temp* FAREN) + HEIT;
  }
  else if(unit ==3 )
  {
    temperature = temp + KELVIN;
  }
  return temperature;

}
//Read I2C data one single byte 
int I2C_Read_Byte_Data(int file , uint8_t *data)
{

	if(read(file,data,1) != 1)
	{
		perror("Error :I2C BYTE Data Reading Failed!\n");
		return EXIT_FAILURE;
	}
	return EXIT_SUCCESS;
}
//Read I2C data one single word 
int I2C_Read_Word(int file , uint8_t *data)
{
	if(read(file,data,2)!=2)
	{
		perror("Error :I2C WORD Data Reading Failed!\n");
		return EXIT_FAILURE;
	}
	return EXIT_SUCCESS;
}

//Write I2C data one single byte
int I2C_Write_Byte(int file , uint8_t data)
{
	if(write(file,&data,sizeof(data))!=1)
	{
		perror("Error :I2C BYTE Data Write Failed!\n");
		return EXIT_FAILURE;
	}
	return EXIT_SUCCESS;
}

//Write I2C data one single word
int I2C_Write_Word(int file , uint8_t *data)
{
	if(read(file,data,3)!=3)
	{
		perror("Error : :I2C WORD Data Write Failed!\n");
		return EXIT_FAILURE;
	}
	return EXIT_SUCCESS;
}

//Write I2C data with 16bit data
int I2C_Write_Bytes(int file , uint16_t * data)
{
	if(write(file,data,2)!=2)
	{
		perror("Error : I2C BYTES Write Failed! \n");
		return EXIT_FAILURE;
	}
	return EXIT_SUCCESS;
}
/*Unit Test to test various functions related to Temperature
 * Author: Harsimransingh Bindra & Yasir Aslam Shah
 * Advance Embedded System Design
 * Spring 2019
 * Definition: Test module to test various functionality for teh temperarture sensor.Includes the following functions:
 * Functions: Test_I2C_init(),Test_Read_Sensor_Celsius(),Test_Read_Sensor_Kelvin(),Test_Read_Sensor_Farenheit(),Test_Read_TLow(),
Test_Read_THigh(int file),Test_Read_Resolution(),Test_Read_Fault_Bits(),Test_Clear_ShutDown(),Test_Set_ShutDown(),
Test_Set_EM(),Test_Set_Conversion(),Test_Write_Configuration(),MY_ASSERT_NOT_EQUAL()
 * */

//Standard Header files
#include <errno.h>
#include <stdlib.h>
#include <stdio.h>

//User Defined Header files
#include "temperature.h"
#include "test_temp.h"
#include "test_conversion.h"

//Macros
#define status EXIT_FAILURE


//function defnition:
/* --------------------------------------------------------------------------*/
/**
 * @Synopsis  :Test function to test the I2C path and bus allocation to the slave(1)
 *
 * @Param file:File is used to allocate the I2C bus  and path to the slave
 *
 * @Returns   :returns exit status upon the success or failure of function
 */
/* ----------------------------------------------------------------------------*/
int Test_I2C_init_Temp(int file)
{
	printf("\nTest I2C Init:");
	int result = I2C_init(&file,1);
	int result1=MY_ASSERT_NOT_EQUAL(result);
  if(result1 == EXIT_FAILURE)
  {
    return EXIT_FAILURE;
  }
  return EXIT_SUCCESS;
}
/* --------------------------------------------------------------------------*/
/**
 * @Synopsis  :test functiion to test the temperature sensor readaing in Celsius
 *
 * @Param file: File is used to allocate the path and bus to the I2C slave
 *
 * @Returns   :returns the exit status upon success or failure
 */
/* ----------------------------------------------------------------------------*/
int Test_Read_Sensor_Celsius(int file)
{
	printf("\nTest Read Celsius:");
  float temp_value=0;
	I2C_init(&file,1);	
	int result = Read_Temperature(file,1, &temp_value);
	int result1=MY_ASSERT_NOT_EQUAL(result);
  if(result1 == EXIT_FAILURE)
  {
    return EXIT_FAILURE;
  }
  return EXIT_SUCCESS;
}
/* --------------------------------------------------------------------------*/
/**
 * @Synopsis  :test functiion to test the temperature sensor readaing in Kelvin
 *
 * @Param file: File is used to allocate the path and bus to the I2C slave
 *
 * @Returns   :returns the exit status upon success or failure
 */
/* ----------------------------------------------------------------------------*/
int Test_Read_Sensor_Kelvin(int file)
{
	printf("\nTest Read Kelvin:");
	I2C_init(&file,1);	
	float temp_value = 0;
  int result = Read_Temperature(file,2, &temp_value);
	int result1=MY_ASSERT_NOT_EQUAL(result);
  if(result1 == EXIT_FAILURE)
  {
    return EXIT_FAILURE;
  }
  return EXIT_SUCCESS;
}
/* --------------------------------------------------------------------------*/
/**
 * @Synopsis  :test functiion to test the temperature sensor readaing in Farenheit
 *
 * @Param file: File is used to allocate the path and bus to the I2C slave
 *
 * @Returns   :returns the exit status upon success or failure
 */
/* ----------------------------------------------------------------------------*/
int Test_Read_Sensor_Farenheit(int file)
{
	printf("\nTest Read Farenheit:");
	I2C_init(&file,1);	
	float temp_value =0;
  int result = Read_Temperature(file,3,&temp_value);
	int result1=MY_ASSERT_NOT_EQUAL(result);
  if(result1 == EXIT_FAILURE)
  {
    return EXIT_FAILURE;
  }
  return EXIT_SUCCESS;
}
/* --------------------------------------------------------------------------*/
/**
 * @Synopsis  :test function to read the Tlow value from the TMP102 Sensor,TLOW 
 * stands for thethreshold low value for the alert to occur
 *
 * @Param file: File is used to allocate the path and bus to the I2C slave
 *
 * @Returns   :returns exit status upon success or failure
 */
/* ----------------------------------------------------------------------------*/
int Test_Read_TLow(int file)
{
	printf("\nTest Read Sensor TLow:");
	I2C_init(&file,1);
	int result = Read_TLow(file);
	int result1=MY_ASSERT_NOT_EQUAL(result);
  if(result1 == EXIT_FAILURE)
  {
    return EXIT_FAILURE;
  }
  return EXIT_SUCCESS;
}
/* --------------------------------------------------------------------------*/
/**
 * @Synopsis  :test function to read the THigh value from the TMP102 Sensor,
 * THigh stands for thethreshold low value for the alert to occur
 *
 * @Param file: File is used to allocate the path and bus to the I2C slave
 *
 * @Returns   :returns exit status upon success or failure
 */
/* ----------------------------------------------------------------------------*/
int Test_Read_THigh(int file)
{
	printf("\nTest Read Sensor THigh:");
	I2C_init(&file,1);
	int result = Read_THigh(file);
	int result1=MY_ASSERT_NOT_EQUAL(result);
  if(result1 == EXIT_FAILURE)
  {
    return EXIT_FAILURE;
  }
  return EXIT_SUCCESS;
}
/* --------------------------------------------------------------------------*/
/**
 * @Synopsis  :test function to configure the sensor resolution  value from the 
 * TMP102 Sensor,the sensor has a 12 bit and a 13 bit resolution
 *
 * @Param file: File is used to allocate the path and bus to the I2C slave
 *
 * @Returns   :returns exit status upon success or failure
 */
/* ----------------------------------------------------------------------------*/
int Test_Read_Resolution(int file)
{
	printf("\nTest Read Resolution:");
	I2C_init(&file,1);
	int result = Read_Resolution(file);
	int result1=MY_ASSERT_NOT_EQUAL(result);
  if(result1 == EXIT_FAILURE)
  {
    return EXIT_FAILURE;
  }
  return EXIT_SUCCESS;
}
/* --------------------------------------------------------------------------*/
/**
 * @Synopsis  :test function to configure the fault bits of sensor TMP102,a consecutive 
 * fault options of 1,2,4 and 6 are avaialble for the system to trigger the alert
 *
 * @Param file: File is used to allocate the path and bus to the I2C slave
 *
 * @Returns   :returns exit status upon success or failure
 */
/* ----------------------------------------------------------------------------*/
int Test_Read_Fault_Bits(int file)
{
	printf("\nTest Read Fault Bits:");
	I2C_init(&file,1);
	int result = Read_Fault_Bits(file);
	int result1=MY_ASSERT_NOT_EQUAL(result);
  if(result1 == EXIT_FAILURE)
  {
    return EXIT_FAILURE;
  }
  return EXIT_SUCCESS;
}
/* --------------------------------------------------------------------------*/
/**
 * @Synopsis  :test function to configure the shutdown feature for the temperature
 * sensor, setting the shutdown bit enables the shutdown mode
 *
 * @Param file: File is used to allocate the path and bus to the I2C slave
 *
 * @Returns   :returns exit status upon success or failure
 */
/* ----------------------------------------------------------------------------*/
int Test_Clear_ShutDown(int file)
{
	printf("\nTest ShutDown Disable:");
	I2C_init(&file,1);
	int result = Clear_ShutDown(file);
	int result1=MY_ASSERT_NOT_EQUAL(result);
  if(result1 == EXIT_FAILURE)
  {
    return EXIT_FAILURE;
  }
  return EXIT_SUCCESS;
}
/* --------------------------------------------------------------------------*/
/**
 * @Synopsis  :test function to configure the shutdown feature for the temperature
 * sensor, clearing the shutdown bit disables the shutdown mode
 *
 * @Param file: File is used to allocate the path and bus to the I2C slave
 *
 * @Returns   :returns exit status upon success or failure
 */
/* ----------------------------------------------------------------------------*/
int Test_Set_ShutDown(int file)
{
	printf("\nTest Read Set ShutDown:");
	I2C_init(&file,1);
	int result = Set_ShutDown(file);
	int result1=MY_ASSERT_NOT_EQUAL(result);
  if(result1 == EXIT_FAILURE)
  {
    return EXIT_FAILURE;
  }
  return EXIT_SUCCESS;
}
/* --------------------------------------------------------------------------*/
/**
 * @Synopsis  :test function to configure the Extended Mode, extended mode allows 13 bit 
 * temperature reading allowing to read temperature above 128C
 *
 * @Param file: File is used to allocate the path and bus to the I2C slave
 *
 * @Returns   :returns exit status upon success or failure
 */
/* ----------------------------------------------------------------------------*/
int Test_Set_EM(int file)
{
	printf("\nTest Read Set Extended Mode:");
	I2C_init(&file,1);
	int result = Set_EM(file);
	int result1=MY_ASSERT_NOT_EQUAL(result);
  if(result1 == EXIT_FAILURE)
  {
    return EXIT_FAILURE;
  }
  return EXIT_SUCCESS;
}
/* --------------------------------------------------------------------------*/
/**
 * @Synopsis  :test function to configure the conversion rate for the sensor, 
 * conversion rate of 1Hz,4Hz and 8Hz are avaialable with 4Hz as default
 *
 * @Param file: File is used to allocate the path and bus to the I2C slave
 *
 * @Returns   :returns exit status upon success or failure
 */
/* ----------------------------------------------------------------------------*/
int Test_Set_Conversion(int file)
{
	printf("\nTest Read Set Conversion:");
	I2C_init(&file,1);
	int result = Set_Conversion(file);
	int result1=MY_ASSERT_NOT_EQUAL(result);
  if(result1 == EXIT_FAILURE)
  {
    return EXIT_FAILURE;
  }
  return EXIT_SUCCESS;
}
/* --------------------------------------------------------------------------*/
/**
 * @Synopsis  :test function to configure the write configuration register to 
 * enable and disable various features in TMP 102
 *
 * @Param file: File is used to allocate the path and bus to the I2C slave
 *
 * @Returns   :returns exit status upon success or failure
 */
/* ----------------------------------------------------------------------------*/
int Test_Write_Configuration(int file)
{
	printf("\nTest Write Configuration:");
	I2C_init(&file,1);
  int value = 0;
	int result = Write_Configuration(file,value);
	int result1=MY_ASSERT_NOT_EQUAL(result);
  if(result1 == EXIT_FAILURE)
  {
    return EXIT_FAILURE;
  }
  return EXIT_SUCCESS;
}
/* --------------------------------------------------------------------------*/
/**
 * @Synopsis  :test function to assert if the expected value is not equal to
 * the return value of the test function, and returns PASS if not equal to the 
 * EXIT_FAILURE or Fail if equal
 *
 * @Param result: the result contains the return value of the tested function 
 */
/* ----------------------------------------------------------------------------*/
/*int MY_ASSERT_NOT_EQUAL(int result)
{
	if(result != status)
	{
		printf("Pass!\n");
		return EXIT_SUCCESS;
	}
	else 
  {
    printf("Fail!");
    return EXIT_FAILURE;
  }
}*/
/* --------------------------------------------------------------------------*/
/**
 * @Synopsis  :test function to run all the test functions for temperature sensor
 *
 * @Param result: the result contains the return value of the tested function 
 */
/* ----------------------------------------------------------------------------*/
int main_temp(void)
{
	int file;

	int res = Test_I2C_init_Temp(file);
	if(res ==EXIT_FAILURE)
  {
    return EXIT_FAILURE;
  }
  res = Test_Read_Sensor_Celsius(file);
	if(res ==EXIT_FAILURE)
  {
    return EXIT_FAILURE;
  }
  res = Test_Read_Sensor_Kelvin(file);	
	if(res ==EXIT_FAILURE)
  {
    return EXIT_FAILURE;
  }
  res = Test_Read_Sensor_Farenheit(file);
	if(res ==EXIT_FAILURE)
  {
    return EXIT_FAILURE;
  }
  res = Test_Write_Configuration(file);
	if(res ==EXIT_FAILURE)
  {
    return EXIT_FAILURE;
  }
  res = Test_Read_TLow(file);
	if(res ==EXIT_FAILURE)
  {
    return EXIT_FAILURE;
  }
  res = Test_Read_THigh(file);
	if(res ==EXIT_FAILURE)
  {
    return EXIT_FAILURE;
  }
  res = Test_Read_Resolution(file);
	if(res ==EXIT_FAILURE)
  {
    return EXIT_FAILURE;
  }
  res = Test_Read_Fault_Bits(file);
	if(res ==EXIT_FAILURE)
  {
    return EXIT_FAILURE;
  }
  res = Test_Clear_ShutDown(file);
	if(res ==EXIT_FAILURE)
  {
    return EXIT_FAILURE;
  }
  res = Test_Set_ShutDown(file);
	if(res ==EXIT_FAILURE)
  {
    return EXIT_FAILURE;
  }
  res = Test_Set_EM(file);
	if(res ==EXIT_FAILURE)
  {
    return EXIT_FAILURE;
  }
  res = Test_Set_Conversion(file);
	if(res ==EXIT_FAILURE)
  {
    return EXIT_FAILURE;
  }
  res = Test_Write_Configuration(file);
  if(res ==EXIT_FAILURE)
  {
    return EXIT_FAILURE;
  }
  return EXIT_SUCCESS;
}
/*Unit Test to test various functions related to Light Sensor APDS 9301
 * Author: Harsimransingh Bindra & Yasir Aslam Shah
 * Advance Embedded System Design
 * Spring 2019
 * Definition: Test module to test various functionality for the Light sensor.Includes the following functions:
 * Functions:MY_ASSERT_NOT_EQUAL(),Test_I2C_init(),Test_Turn_on_light_sensor(),Test_Check_PowerUp(),Test_Read_Sensor_ID(),Test_Light_Sensor(),Test_Write_Interrupt(),Test_Read_Interrupt(),int Test_Status()
 * */

//Standard Header Files
#include <errno.h>
#include <stdlib.h>
#include <stdio.h>

//User Defined Header Files
#include "light.h"
#include "test_light.h"
#include "test_conversion.h"

//macros
#define status EXIT_FAILURE


//Function Defnition:
/* --------------------------------------------------------------------------*/
/**
 * @Synopsis  :Test function to test the I2C path and bus allocation to the slave(2)
 *
 * @Param file:File is used to allocate the I2C bus  and path to the slave
 *
 * @Returns   :returns exit status upon the success or failure of function
 */
/* ----------------------------------------------------------------------------*/
int Test_I2C_init_Light(int file)
{
	printf("\nTest I2C Init:");
	int result = I2C_init(&file,2);
	int result1=MY_ASSERT_NOT_EQUAL(result);
  if(result1 == EXIT_FAILURE)
  {
    return EXIT_FAILURE;
  }
  return EXIT_SUCCESS;
}
/* --------------------------------------------------------------------------*/
/**
 * @Synopsis  :Test function to test the powering up of Sensor by writing to the 
 * control register
 *
 * @Param file:File is used to allocate the I2C bus  and path to the slave
 *
 * @Returns   :returns exit status upon the success or failure of function
 */
/* ----------------------------------------------------------------------------*/
int Test_Turn_on_light_sensor(int file)
{
	printf("\nTest Turn Sensor ON:");
	I2C_init(&file,2);	
	int result = Turn_on_Light_sensor(file);
    int result1=MY_ASSERT_NOT_EQUAL(result);
  if(result1 == EXIT_FAILURE)
  {
    return EXIT_FAILURE;
  }
  return EXIT_SUCCESS;
}
/* --------------------------------------------------------------------------*/
/**
 * @Synopsis  :Test function to check if the powering up the sensor is successfull
 * or not 
 *
 * @Param file:File is used to allocate the I2C bus  and path to the slave
 *
 * @Returns   :returns exit status upon the success or failure of function
 */
/* ----------------------------------------------------------------------------*/
int Test_Check_PowerUp(int file)
{
	printf("\nTest Check Power Up:");
	I2C_init(&file,2);
	Turn_on_Light_sensor(file);
	int result = Check_PowerUp(file);
	int result1=MY_ASSERT_NOT_EQUAL(result);
  if(result1 == EXIT_FAILURE)
  {
    return EXIT_FAILURE;
  }
  return EXIT_SUCCESS;
}
/* --------------------------------------------------------------------------*/
/**
 * @Synopsis  :Test function to read the sensor id of Light APDS 9301 to ensure the
 * I2C is working or not
 *
 * @Param file:File is used to allocate the I2C bus  and path to the slave
 *
 * @Returns   :returns exit status upon the success or failure of function
 */
/* ----------------------------------------------------------------------------*/
int Test_Read_Sensor_ID(int file,uint8_t SensorID)
{
	printf("\nTest Read Sensor ID:");
	I2C_init(&file,2);
	Turn_on_Light_sensor(file);
	int result = Read_Sensor_ID(file,&SensorID);
	int result1=MY_ASSERT_NOT_EQUAL(result);
  if(result1 == EXIT_FAILURE)
  {
    return EXIT_FAILURE;
  }
  return EXIT_SUCCESS;
}
/* --------------------------------------------------------------------------*/
/**
 * @Synopsis  :Test function to test the Light sensor and ensure if the values 
 * returned are correct and changes as per a change in ambient light around the
 * sensor
 *
 * @Param file:File is used to allocate the I2C bus  and path to the slave
 *
 * @Returns   :returns exit status upon the success or failure of function
 */
/* ----------------------------------------------------------------------------*/
int Test_Light_Sensor(int file)
{
	printf("\nTest Light Sensor:");
	I2C_init(&file,2);
	Turn_on_Light_sensor(file);
  float light_value;
	int result = Read_Light_Sensor(file,&light_value);
	int result1=MY_ASSERT_NOT_EQUAL(result);
  if(result1 == EXIT_FAILURE)
  {
    return EXIT_FAILURE;
  }
  return EXIT_SUCCESS;
}
/* --------------------------------------------------------------------------*/
/**
 * @Synopsis  :Test function to test the Light sensor by reading from the 16bit 
 * channels from the sensor
 *
 * @Param file:File is used to allocate the I2C bus  and path to the slave
 *
 * @Returns   :returns exit status upon the success or failure of function
 */
/* ----------------------------------------------------------------------------*/
int Test_Read_Data(int file)
{
	printf("\nTest Light Sensor Read Data:");
	I2C_init(&file,2);
	Turn_on_Light_sensor(file);
	int result = Read_Data(file,1);
	int result1=MY_ASSERT_NOT_EQUAL(result);
  if(result1 == EXIT_FAILURE)
  {
    return EXIT_FAILURE;
  }
  return EXIT_SUCCESS;
}
/* --------------------------------------------------------------------------*/
/**
 * @Synopsis  :Test function to configure the interrupt by writing the High High, 
 * High Low, Low High and Low Low to the Sensor.
 *
 * @Param file:File is used to allocate the I2C bus  and path to the slave
 * @Param SensorID: is a paramameter to select the Light Sensor as SensorID:2
 *
 * @Returns   :returns exit status upon the success or failure of function
 */
/* ----------------------------------------------------------------------------*/
int Test_Write_Interrupt(int file, uint8_t SensorID)
{
	printf("\nTest Write Interrupt:");
	I2C_init(&file,2);
	Turn_on_Light_sensor(file);
	int result = Write_Interrupt(file,&SensorID);
	int result1=MY_ASSERT_NOT_EQUAL(result);
  if(result1 == EXIT_FAILURE)
  {
    return EXIT_FAILURE;
  }
  return EXIT_SUCCESS;
}
/* --------------------------------------------------------------------------*/
/**
 * @Synopsis  :Test function to check if the values returned after writing the 
 * interrupt values are returned to be same after reading them back
 *
 * @Param file:File is used to allocate the I2C bus  and path to the slave
 *
 * @Returns   :returns exit status upon the success or failure of function
 */
/* ----------------------------------------------------------------------------*/
int Test_Read_Interrupt(int file)
{
	printf("\nTest Read Interrupt:");
	I2C_init(&file,2);
	Turn_on_Light_sensor(file);
	int result = Read_Interrupt(file);
  int result1=MY_ASSERT_NOT_EQUAL(result);
  if(result1 == EXIT_FAILURE)
  {
    return EXIT_FAILURE;
  }
  return EXIT_SUCCESS;
}
/* --------------------------------------------------------------------------*/
/**
 * @Synopsis  :Test function to check the state of the system to be DARK or LIGHT 
 * based on the LUX values
 *
 * @Param file:File is used to allocate the I2C bus  and path to the slave
 *
 * @Returns   :returns exit status upon the success or failure of function
 */
/* ----------------------------------------------------------------------------*/
int Test_Status(int file)
{
	printf("\nTest Status:");
	I2C_init(&file,2); 
	Turn_on_Light_sensor(file);
	int result = Check_PowerUp(file);
	int result1=MY_ASSERT_NOT_EQUAL(result);
  if(result1 == EXIT_FAILURE)
  {
    return EXIT_FAILURE;
  }
  return EXIT_SUCCESS;
}
/* --------------------------------------------------------------------------*/
/**
 * @Synopsis  :test function to assert if the expected value is not equal to
 * the return value of the test function, and returns PASS if not equal to the 
 * EXIT_FAILURE or Fail if equal
 *
 * @Param result: the result contains the return value of the tested function 
 */
/* ----------------------------------------------------------------------------*/
/*int MY_ASSERT_NOT_EQUAL(int result)
{
	if(result != status)
	{
		printf("Pass!\n");
		return EXIT_SUCCESS;
	}
	else
  {
    printf("Fail!");
    return EXIT_FAILURE;
  }
}*/
/* --------------------------------------------------------------------------*/
/**
 * @Synopsis  :test function to run all the test functions for the light sensor
 *
 * @Param result: the result contains the return value of the tested function 
 */
/* ----------------------------------------------------------------------------*/
int main_light(void)
{
	int file;
	uint8_t SensorID;
	uint8_t in_value;

	int res = Test_I2C_init_Light(file);
	if(res ==EXIT_FAILURE)
  {
    return EXIT_FAILURE;
  }
  res = Test_Turn_on_light_sensor(file);
	if(res ==EXIT_FAILURE)
  {
    return EXIT_FAILURE;
  }
  res = Test_Check_PowerUp(file);
	if(res ==EXIT_FAILURE)
  {
    return EXIT_FAILURE;
  }
  res = Test_Read_Sensor_ID(file,SensorID);
	if(res ==EXIT_FAILURE)
  {
    return EXIT_FAILURE;
  }
  res = Test_Light_Sensor(file);
	if(res ==EXIT_FAILURE)
  {
    return EXIT_FAILURE;
  }
  res = Test_Status(file);
	if(res ==EXIT_FAILURE)
  {
    return EXIT_FAILURE;
  }
  res = Test_Write_Interrupt(file,SensorID);
	if(res ==EXIT_FAILURE)
  {
    return EXIT_FAILURE;
  }
  res = Test_Read_Interrupt(file);
  if(res ==EXIT_FAILURE)
  {
    return EXIT_FAILURE;
  }
  return EXIT_SUCCESS;
}

#include "logger.h"
#include "light.h"
#include "temperature.h"
#include "socket.h"

void *socket_function(void *arg)
{
  struct sockaddr_in client_address;
  int listen_fd = 0;
  int result_client;
  int addr_length;
  struct sockaddr_in server;
  int nbytes_recieve, nbytes_send;
  char recieve_buffer[MAXBUFSIZE];
  bzero((char *)&server, sizeof(server));
  server.sin_family = AF_INET;
  server.sin_addr.s_addr = INADDR_ANY;
  server.sin_port = htons(PORT_NUMBER);

  if((listen_fd = socket(AF_INET,SOCK_STREAM, 0)) < 0)
  {
    printf("ERROR: CREATING SOCKET\n");
    exit(1);
  }

  /*check if bind is success*/
  if((bind(listen_fd,(struct sockaddr *)&server,sizeof(server))) < 0)
  {
    printf("ERROR : BINDING\n");
    exit(1);
  }

  /*listen for incoming connections*/
  if(listen(listen_fd,1000000) != 0)
  {
    perror("ERROR: listen()");
    exit(1);
  }

  addr_length = sizeof(client_address);
  int i = 0;
  int child_pid = 0;
  while(exit_flag != 1)
  {
    printf("\nWaiting To Recieve Command\n");
    result_client = accept(listen_fd,(struct sockaddr*)&client_address , &addr_length);
    if(result_client < 0)
    {
      printf("\nError in accept\n");
      exit(1);
    }
    nbytes_recieve = read(result_client,recieve_buffer,MAXBUFSIZE);
    if(nbytes_recieve < 0)
    {
      printf("\nError while recieving command\n");
      shutdown(result_client, SHUT_RDWR);
      close(result_client);
      //return;
    }
    else if(nbytes_recieve == 0)
    {
      printf("\nNo command recieved\n");
      shutdown(result_client, SHUT_RDWR);
      close(result_client);
      //return;
    }
    else
    { 
      printf("\n\n\nRECIEVED COMMAND IS:%s\n\n\n",recieve_buffer);
      msg_struct *msg = (msg_struct *)malloc(sizeof(msg_struct));
      if(strncmp(recieve_buffer,"TEMPC",5) == 0)
      {
       float temperature_value;
       int result = temp_main(&temperature_value,1); 
       if(result == EXIT_FAILURE)
       {
         printf("\nError socket tempc sensor\n");
         memcpy(msg->level,"ERROR",strlen("ERROR"));
         nbytes_send = send(result_client, (void *)msg, sizeof(*msg), 0);
       }
       else
       {
         memset(msg->thread_name,'\0',sizeof(msg->thread_name));
         memcpy(msg->thread_name,"temp",strlen("temp"));
         msg->sensor_value = temperature_value;
         memset(msg->level,'\0',sizeof(msg->level));
         memcpy(msg->level,"DATA",strlen("DATA"));
         msg->unit = 'C';
         printf("\nSENDING DATA\n");
         nbytes_send = send(result_client, (void *)msg, sizeof(*msg), 0);
         if(nbytes_send < 0)
         {
           printf("\n\nERRO SENDING SENSOR VALUE\n\n");
         }
       }
      }
      else if(strncmp(recieve_buffer,"TEMPK",5) == 0)
      {
        float temperature_value;
        int result = temp_main(&temperature_value,2); 
        if(result == EXIT_FAILURE)
        {
          printf("\nError socket tempk sensor\n");
          memcpy(msg->level,"ERROR",strlen("ERROR"));
          nbytes_send = send(result_client, (void *)msg, sizeof(*msg), 0);
        }
        else
        {
          memset(msg->thread_name,'\0',sizeof(msg->thread_name));
          memcpy(msg->thread_name,"temp",strlen("temp"));
          msg->sensor_value = temperature_value;
          memset(msg->level,'\0',sizeof(msg->level));
          memcpy(msg->level,"DATA",strlen("DATA"));
          msg->unit = 'K';
          nbytes_send = send(result_client, (void *)msg, sizeof(*msg), 0);
        }

      }
      else if(strncmp(recieve_buffer,"TEMPF",5) == 0)
      {
        float temperature_value;
        int result=temp_main(&temperature_value,3); 
        if(result == EXIT_FAILURE)
        {
          printf("\nError socket tempf sensor\n");
          memcpy(msg->level,"ERROR",strlen("ERROR"));
          nbytes_send = send(result_client, (void *)msg, sizeof(*msg), 0);
        }
        else
        {
          memset(msg->thread_name,'\0',sizeof(msg->thread_name));
         memcpy(msg->thread_name,"temp",strlen("temp"));
         msg->sensor_value = temperature_value;
         memset(msg->level,'\0',sizeof(msg->level));
         memcpy(msg->level,"DATA",strlen("DATA"));
         msg->unit = 'F';
         nbytes_send = send(result_client, (void *)msg, sizeof(*msg), 0);
       }

      }
      else if(strncmp(recieve_buffer,"LIGHT",5) == 0)
      {
       float light_value;
       int result = Light_main(&light_value); 
       if(result == EXIT_FAILURE)
       {
         printf("\nError socket light sensor\n");
         memcpy(msg->level,"ERROR",strlen("ERROR"));
         nbytes_send = send(result_client, (void *)msg, sizeof(*msg), 0);
       }
       else
       {
         memset(msg->thread_name,'\0',sizeof(msg->thread_name));
         memcpy(msg->thread_name,"light",strlen("light"));
         msg->sensor_value = light_value;
         memset(msg->level,'\0',sizeof(msg->level));
         memcpy(msg->level,"DATA",strlen("DATA"));
         msg->unit = 'L';
         nbytes_send = send(result_client, (void *)msg, sizeof(*msg), 0);
       }
      }
      free(msg);
    }
  }
}


/* -.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.
* File Name : main.c
* Creation Date : 18-03-2019
* Last Modified : Sun 31 Mar 2019 00:9:56 PM MDT
* Created By : Harsimransingh
* Description: Source file to create all needed pthreads and implement the heartbeat functionality
*
* References
*           -https://www.geeksforgeeks.org/mutex-lock-for-linux-thread-synchronization/
*
_._._._._._._._._._._._._._._._._._._._._.*/


/*User defined libraries*/
#include "logger.h"
#include "light.h"
#include "temperature.h"
#include "socket.h"
#include "user_led.h"
#include "intial_test.h"
void intHandler(int dummy) 
{
  printf("\nSIGNAL HANDLER CAUGHT\n");
  exit_flag = 1;
}

void main(int argc, char *argv[])
{
  signal(SIGINT, intHandler);
  if(argc < 2)
  {
    printf("\nPlease input the log file name\n");
    exit(0);
  }
  pthread_t light_task, temperature_task, logging_task, socket_task;
  
  /*Mutex lock for synchronized access of logger function*/
  if(pthread_mutex_init(&logger_mutex,NULL)!= 0)
  {
    printf("\nlogger mutex creation failed\n");
  }
  /*Mutex lock for I2C bus synchronisation*/
  if(pthread_mutex_init(&bus_lock,NULL)!= 0)
  {
    printf("\nBus lock mutex creation failed\n");

  }
  /*Mutex lock for heartbeat pthread_cond_timedwait call*/
  if(pthread_mutex_init(&heartbeat_mutex,NULL)!=0)
  {
    printf("\nheartbeat mutex intialization failed\n");
    return;
  }
  /*conditional variable to implement heartbeat*/
  if(pthread_cond_init(&temp_thread_cond,NULL)!=0)
  {
    printf("\ntemp Condition variable creation failed\n");
    return;
  }
  /*conditional variable to implement heartbeat*/
  if(pthread_cond_init(&light_thread_cond,NULL)!=0)
  {
    printf("\ntemp Condition variable creation failed\n");
    return;
  }
  if(pthread_cond_init(&logger_thread_cond,NULL)!=0)
  {
    printf("\ntemp Condition variable creation failed\n");
    return;
  }
 
  thread_struct *thread_input = (thread_struct *)malloc(sizeof(struct thread_content));
  thread_input->log_file = argv[1];
  int result = intial_test(thread_input->log_file);
  if(result == EXIT_SUCCESS)
  {
    /*create light sensor thread*/
    if(!pthread_create(&light_task, NULL, light_function, (void *)thread_input))
    {
      logging_function(getppid(),getpid(),syscall(SYS_gettid),thread_input->log_file,"Thread info: MAIN\nLIGHT Thread created Successfully\nLOG level:INFO",NULL);
    }
    else
    {
      printf("LIGHT read Thread creation failed\n");
      logging_function(getppid(),getpid(),syscall(SYS_gettid),thread_input->log_file,"LIGHT read Thread creation failed",NULL);
    }

    /*create temperature sensor thread*/
    if(!pthread_create (&temperature_task, NULL, temperature_function, (void*)thread_input))
    {
      logging_function(getppid(),getpid(),syscall(SYS_gettid),thread_input->log_file,"Thread info: MAIN\ntemperature thread created successfully\nLOG level:INFO",NULL);
    }
    else
    {
      printf("temperature Thread creation failed\n");
      logging_function(getppid(),getpid(),syscall(SYS_gettid),thread_input->log_file,"temperature Thread creation failed",NULL);
    }

    /*create logging task thread*/
    if(!pthread_create (&logging_task, NULL, logging_thread, (void*)thread_input))
    {
      logging_function(getppid(),getpid(),syscall(SYS_gettid),thread_input->log_file,"Thread info: MAIN\nlogging thread created successfully\nLOG level:INFO",NULL);
    }
    else
    {
      printf("logging Thread creation failed\n");
      logging_function(getppid(),getpid(),syscall(SYS_gettid),thread_input->log_file,"logging Thread creation failed",NULL);
    }

    /*create socket task thread*/
    if(!pthread_create (&socket_task, NULL, socket_function, (void*)thread_input))
    {
      logging_function(getppid(),getpid(),syscall(SYS_gettid),thread_input->log_file,"Thread info: MAIN\nsocket thread created successfully\nLOG level:INFO",NULL);
    }
    else
    {
      printf("socket Thread creation failed\n");
      logging_function(getppid(),getpid(),syscall(SYS_gettid),thread_input->log_file,"socket Thread creation failed",NULL);
    }
    int return_value = 0;
    while(exit_flag != 1)
    {
      /*Toggle led to indicate prgram is still running*/
      static int light_led_status;
      led_control(BLUE,light_led_status);
      light_led_status ^=1;

      /*heartbeat timer setup*/
      struct timespec ts;
      ts = timer_setup(4,4000000);

      /*to check if temperature thread is alive*/
      pthread_mutex_lock(&heartbeat_mutex);
      return_value = pthread_cond_timedwait(&temp_thread_cond,&heartbeat_mutex,&ts);
      pthread_mutex_unlock(&heartbeat_mutex);
      if(return_value != 0 && exit_flag != 1)
      {
        intHandler(3);
        msg_struct *msg = (msg_struct *)malloc(sizeof(msg_struct));
        memset(msg->thread_name,'\0',sizeof(msg->thread_name));
        memcpy(msg->thread_name,"MAIN",strlen("MAIN"));
        memset(msg->level,'\0',sizeof(msg->level));
        memcpy(msg->level,"ALERT",strlen("ALERT"));
        msg->unit = '\0';
        logging_function(getppid(),getpid(),syscall(SYS_gettid),thread_input->log_file,"Temperature thread stuck",msg);
        break;
      }

      /*to check is light thread is alive or not*/
      pthread_mutex_lock(&heartbeat_mutex);
      return_value = pthread_cond_timedwait(&light_thread_cond,&heartbeat_mutex,&ts);
      pthread_mutex_unlock(&heartbeat_mutex);
      if(return_value != 0 && exit_flag != 1)
      {
        intHandler(3);
        msg_struct *msg = (msg_struct *)malloc(sizeof(msg_struct));
        memset(msg->thread_name,'\0',sizeof(msg->thread_name));
        memcpy(msg->thread_name,"MAIN",strlen("MAIN"));
        memset(msg->level,'\0',sizeof(msg->level));
        memcpy(msg->level,"ALERT",strlen("ALERT"));
        msg->unit = '\0';
        logging_function(getppid(),getpid(),syscall(SYS_gettid),thread_input->log_file,"light thread stuck",msg);
        break;
      }
      pthread_mutex_lock(&heartbeat_mutex);
      return_value = pthread_cond_timedwait(&logger_thread_cond,&heartbeat_mutex,&ts);
      pthread_mutex_unlock(&heartbeat_mutex);
      if(return_value != 0 && exit_flag != 1)
      {
        intHandler(3);
        msg_struct *msg = (msg_struct *)malloc(sizeof(msg_struct));
        memset(msg->thread_name,'\0',sizeof(msg->thread_name));
        memcpy(msg->thread_name,"MAIN",strlen("MAIN"));
        memset(msg->level,'\0',sizeof(msg->level));
        memcpy(msg->level,"ALERT",strlen("ALERT"));
        msg->unit = '\0';
        logging_function(getppid(),getpid(),syscall(SYS_gettid),thread_input->log_file,"logger thread stuck",msg);
        break;
      }
    }

    printf("\nREACHED HERE\n");
    /*join all the thread in completion*/
    pthread_join(temperature_task, NULL);
    pthread_join(light_task, NULL);
    pthread_join(logging_task,NULL);
  }
  printf("\nDestroy all\n");
  if(pthread_mutex_destroy(&heartbeat_mutex)!=0)
  {
    printf("\nheartbeat_mutex destroy: FAILED\n");
  }
  if(pthread_mutex_destroy(&bus_lock) != 0)
  {
    printf("\nbus_lock destroy: FAILED\n");
  }
  if(pthread_mutex_destroy(&logger_mutex) != 0)
  {
    printf("\nlogger_mutex destroy: FAILED\n");
  }
  if(pthread_cond_destroy(&temp_thread_cond)!=0)
  {
    printf("\ntemp_thread_cond destroy: FAILED\n");
  }
  if(pthread_cond_destroy(&light_thread_cond) != 0)
  {
    printf("\nlight_thread_cond destroy: FAILED\n");
  } 
}

#include "socket.h"
#include "logger.h"

void main()
{
  int client_id = 0;
  int nbytes_send = 0;
  int nbytes_recieve = 0;
  struct sockaddr_in server_address;
  char recieve_command[10];
  client_id = socket(AF_INET, SOCK_STREAM, 0);
  server_address.sin_family = AF_INET;
  server_address.sin_port = htons(PORT_NUMBER);
  inet_pton(AF_INET,"127.0.0.1",&server_address.sin_addr);
  int connection_status = connect(client_id, (struct sockaddr *) &server_address, sizeof(server_address));
  printf("Successfully connected to server!!!\n");
  printf("\nCOMMAND OPTIONS\n1. TEMPC\n2. TEMPK\n3. TEMPF\n4. LIGHT\n\n");
  printf("Enter command:");
  gets(recieve_command);
  printf("RECIEVED COMMAND IS:%s\n",recieve_command);
  if(strcmp(recieve_command,"TEMPC") == 0 || strcmp(recieve_command,"TEMPK") == 0 || strcmp(recieve_command,"TEMPF") == 0 || strcmp(recieve_command,"LIGHT") == 0)
  {
    nbytes_send = send(client_id,(char *)recieve_command,strlen(recieve_command),0);
    if(nbytes_send < 0)
    {
      printf("error sending\n");
      return;
    }
    else
    {
      printf("\nRECIEVING COMMAND\n");
      msg_struct msg;
      nbytes_recieve = recv(client_id,(char *)&msg,sizeof(msg),0);
      if(nbytes_recieve < 0)
      {
        printf("\nERROR RECIEVING\n");
      }
      else
      {
        printf("\nREACHED HERE %s\n",msg.level);
        if(strncmp(msg.level,"DATA",4) == 0)
        {
          printf("\n\n%s\n\n",msg.level);
          printf("SENSOR:%s\nSensor value: %0.2f%c\n",msg.thread_name,msg.sensor_value,msg.unit);
        }
        else
        { 
          printf("\nSENSOR ERROR\n");
        }
      }
    }
  }
  else
  {
    printf("invalid command!!\n");
    return;
  }
}
/*Unit Test to test various functions related to temperature conversion
 * Author: Harsimransingh Bindra & Yasir Aslam Shah
 * Advance Embedded System Design
 * Spring 2019
 * Definition: Test module to test various functionality for the unit conversion .Includes the following functions:
 * Functions:Test_I2C_init(int file),Test_Read_Temperature_Celsius(int file),Test_Read_Temperature_Kelvin(int file),
 * Test_Read_Temperature_Farenheit(int file),MY_ASSERT_NOT_EQUAL(int result)
 * */

//Standard Library header
#include <errno.h>
#include <stdlib.h>
#include <stdio.h>

//User Defined Header
#include "temperature.h"
#include "i2c.h"
#include "test_conversion.h"

//macros
#define status EXIT_FAILURE


//Function Defnition:
/* --------------------------------------------------------------------------*/
/**
 * @Synopsis  :Test function to test the I2C path and bus allocation to the slave(2)
 *
 * @Param file:File is used to allocate the I2C bus  and path to the slave
 *
 * @Returns   :returns exit status upon the success or failure of function
 */
/* ----------------------------------------------------------------------------*/
int Test_I2C_init_Conversion(int file)
{
	printf("\nTest I2C Init:");
	int result = I2C_init(&file,1);
	MY_ASSERT_NOT_EQUAL(result);
	int result1=MY_ASSERT_NOT_EQUAL(result);
  if(result1 == EXIT_FAILURE)
  {
    return EXIT_FAILURE;
  }
  return EXIT_SUCCESS;
}
/* --------------------------------------------------------------------------*/
/**
 * @Synopsis  :test functiion to test the temperature sensor readaing in Celsius
 *
 * @Param file: File is used to allocate the path and bus to the I2C slave
 *
 * @Returns   :returns the exit status upon success or failure
 */
/* ----------------------------------------------------------------------------*/
int Test_Read_Temperature_Celsius(int file)
{
	printf("\nTest Temperature in Celsius:");
	I2C_init(&file,1);
  float temp_value = 0;
	int result = Read_Temperature(file,1, &temp_value);
	int result1=MY_ASSERT_NOT_EQUAL(result);
  if(result1 == EXIT_FAILURE)
  {
    return EXIT_FAILURE;
  }
  return EXIT_SUCCESS;
}
/* --------------------------------------------------------------------------*/
/**
 * @Synopsis  :test functiion to test the temperature sensor readaing in Kelvin
 *
 * @Param file: File is used to allocate the path and bus to the I2C slave
 *
 * @Returns   :returns the exit status upon success or failure
 */
/* ----------------------------------------------------------------------------*/
int Test_Read_Temperature_Kelvin(int file)
{
	printf("\nTest Temperature in Kelvin:");
	I2C_init(&file,1);
  float temp_value = 0;
	int result = Read_Temperature(file,2, &temp_value);
	int result1=MY_ASSERT_NOT_EQUAL(result);
  if(result1 == EXIT_FAILURE)
  {
    return EXIT_FAILURE;
  }
  return EXIT_SUCCESS;
}
/* --------------------------------------------------------------------------*/
/**
 * @Synopsis  :test functiion to test the temperature sensor readaing in Farenheit
 *
 * @Param file: File is used to allocate the path and bus to the I2C slave
 *
 * @Returns   :returns the exit status upon success or failure
 */
/* ----------------------------------------------------------------------------*/
int Test_Read_Temperature_Farenheit(int file)
{
	printf("\nTest Temperature in Farenheit:");
	I2C_init(&file,1);	
  float temp_value = 0;
	int result = Read_Temperature(file,3, &temp_value);
	int result1=MY_ASSERT_NOT_EQUAL(result);
  if(result1 == EXIT_FAILURE)
  {
    return EXIT_FAILURE;
  }
  return EXIT_SUCCESS;
}
/* --------------------------------------------------------------------------*/
/**
 * @Synopsis  :test function to assert if the expected value is not equal to
 * the return value of the test function, and returns PASS if not equal to the 
 * EXIT_FAILURE or Fail if equal
 *
 * @Param result: the result contains the return value of the tested function 
 */
/* ----------------------------------------------------------------------------*/
int MY_ASSERT_NOT_EQUAL(int result)
{
	if(result != status)
	{
		printf("Pass!\n");
		return EXIT_SUCCESS;
	}
	else
  {
    printf("Fail!");
    return EXIT_FAILURE;
  }
}

/* --------------------------------------------------------------------------*/
/**
 * @Synopsis  :test function to test the unit testing functions
 *
 * @Param result: the result contains the return value of the tested function 
 */
/* ----------------------------------------------------------------------------*/
int main_conversion(void)
{
	int file;

	int res = Test_I2C_init_Conversion(file);
	if(res ==EXIT_FAILURE)
  {
    return EXIT_FAILURE;
  }

  res = Test_Read_Temperature_Celsius(file);
	if(res ==EXIT_FAILURE)
  {
    return EXIT_FAILURE;
  }

  res = Test_Read_Temperature_Kelvin(file);	
  if(res ==EXIT_FAILURE)
  {
    return EXIT_FAILURE;
  }

  Test_Read_Temperature_Farenheit(file);
  if(res ==EXIT_FAILURE)
  {
    return EXIT_FAILURE;
  }
  return EXIT_SUCCESS;
}
/* -.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.
* File Name : initial_test.c
* Creation Date : 31-03-2019
* Last Modified : Sun 31 March 2019 00:07:10 PM MDT
* Created By : Harsimransingh and Yasir Shah
* Description: source file contatining function definition for initial_test function where the startup temperature and light sensor test are run
* Functions:
*           intial_test() to test all sensors before creating threads
* References:
_._._._._._._._._._._._._._._._._._._._._.*/

/*user defined header files*/
#include "logger.h"
#include "temperature.h"
#include "light.h"
#include "test.h"


int intial_test(char *filename)
{
  /*temperature sensor test*/
  int result = main_temp();
  if(result == EXIT_FAILURE)
  { 
      printf("\nTemperature Sensor disconnected!\n");
      /*fill up the message structure*/
      msg_struct *msg = (msg_struct *)malloc(sizeof(msg_struct));
      memset(msg->thread_name,'\0',sizeof(msg->thread_name));
      memcpy(msg->thread_name,"temperature",strlen("temperature"));
      memset(msg->level,'\0',sizeof(msg->level));
      memcpy(msg->level,"ALERT",strlen("ALERT"));
      msg->unit = '\0';
      /*log message*/
      logging_function(getppid(),getpid(),syscall(SYS_gettid),filename,"Temperature sensor not functional",msg);
      return EXIT_FAILURE;
  }
  else if(result == EXIT_SUCCESS)
  {
      printf("\nTemperature Sensor Successfully connected\n");
      /*fill up the message structure*/
      msg_struct *msg = (msg_struct *)malloc(sizeof(msg_struct));
      memset(msg->thread_name,'\0',sizeof(msg->thread_name));
      memcpy(msg->thread_name,"MAIN",strlen("MAIN"));
      memset(msg->level,'\0',sizeof(msg->level));
      memcpy(msg->level,"INFO",strlen("INFO"));
      msg->unit = '\0';
      /*log message*/
      logging_function(getppid(),getpid(),syscall(SYS_gettid),filename,"Temperature sensor working",msg);
  }
  /*light sensor test*/
  result = main_light();
  if(result == EXIT_FAILURE)
  { 
      printf("lightSensor disconnected!\n\n");
      /*fill up the message structure*/
      msg_struct *msg = (msg_struct *)malloc(sizeof(msg_struct));
      memset(msg->thread_name,'\0',sizeof(msg->thread_name));
      memcpy(msg->thread_name,"MAIN",strlen("MAIN"));
      memset(msg->level,'\0',sizeof(msg->level));
      memcpy(msg->level,"ALERT",strlen("ALERT"));
      msg->unit = '\0';
      /*log message*/
      logging_function(getppid(),getpid(),syscall(SYS_gettid),filename,"light sensor not functional",msg);
      return EXIT_FAILURE;
  }
  else if(result == EXIT_SUCCESS)
  {
      printf("Light sensor successfully connected\n\n");
      /*fill up the message structure*/
      msg_struct *msg = (msg_struct *)malloc(sizeof(msg_struct));
      memset(msg->thread_name,'\0',sizeof(msg->thread_name));
      memcpy(msg->thread_name,"MAIN",strlen("MAIN"));
      memset(msg->level,'\0',sizeof(msg->level));
      memcpy(msg->level,"INFO",strlen("INFO"));
      msg->unit = '\0';
      /*log message*/
      logging_function(getppid(),getpid(),syscall(SYS_gettid),filename,"Light sensor working",msg);
  }
  return EXIT_SUCCESS;
}

#include "logger.h"

struct timespec timer_setup(uint32_t second_value, uint32_t nanosec_value)
{
  struct timespec ts;
  struct timeval tp;

  gettimeofday(&tp,NULL);
  ts.tv_sec = tp.tv_sec;
  ts.tv_nsec = tp.tv_usec * 1000;
  ts.tv_sec += second_value;
  ts.tv_nsec += nanosec_value;
  
  return ts;
}

void *logging_thread(void *arg)
{
  thread_struct *logging_thread = (thread_struct *)arg;
  /*light queue attribute settings*/
  mqd_t light_discriptor;
  struct mq_attr attribute;
  attribute.mq_maxmsg = 10;
  attribute.mq_msgsize = sizeof(msg_struct);
  light_discriptor = mq_open ("/light_queue", O_RDWR | O_CREAT, 0666, &attribute);
  if (light_discriptor < 0)
  {
    printf("message queue error\n");
  }
  else
  {
    printf("Successful in creating message queue\n");
  }

  struct mq_attr temp_attribute;
  temp_attribute.mq_maxmsg = 10;
  temp_attribute.mq_msgsize = sizeof(msg_struct);
  /*temperature queue attribute setting*/
  mqd_t temperature_discriptor;
  temperature_discriptor = mq_open ("/temp_queue", O_RDWR | O_CREAT, 0666, &temp_attribute);
  if (temperature_discriptor < 0)
  {
    printf("message queue error\n");
  }
  else
  {
    printf("Successful in creating temp message queue\n");
  }
  while(exit_flag!=1)
  {
    pthread_cond_broadcast(&logger_thread_cond);
    if(light_flag)
    {
      msg_struct *msg = (msg_struct *)malloc(sizeof(msg_struct));
      light_flag = 0;
      if(mq_receive(light_discriptor,(char *)msg,sizeof(msg_struct),0) < 0)
      {
        printf("Error receiving msg to  light queue\n");
      }
      logging_function(getppid(),getpid(),syscall(SYS_gettid),logging_thread->log_file,"Timer event light handler",msg);
    }
    if(temperature_flag)
    {
      temperature_flag = 0;
      msg_struct *msg = (msg_struct *)malloc(sizeof(msg_struct));
      if(mq_receive(temperature_discriptor,(char *)msg,sizeof(msg_struct),0) < 0)
      {
        printf("Error receiving msg to  temperature queue\n");
      }
      logging_function(getppid(),getpid(),syscall(SYS_gettid),logging_thread->log_file,"Timer event temperature handler",msg);
    }
  }
  mq_close(temperature_discriptor);
  mq_close(light_discriptor);
}

void logging_function(int parent_id, int pthread_id, int thread_id, char *file_name,char* ip_str,msg_struct *msg)
{
  pthread_mutex_lock(&logger_mutex); 
  FILE *file_ptr = fopen(file_name,"a");
  struct timeval curr_time;
  gettimeofday(&curr_time, NULL);
  fprintf(file_ptr,"\n[Timestamp: %ld seconds]\n",(curr_time.tv_sec));
  if(msg != NULL)
  {
    if(strcmp(msg->level,"DATA") == 0)
      fprintf(file_ptr,"Thread:%s\nLog level:%s\nsensor_value:%.2f%c\nstate:%s\n",msg->thread_name,msg->level,msg->sensor_value,msg->unit,msg->state);
    else
      fprintf(file_ptr,"Thread:%s\nLog level:%s\n",msg->thread_name,msg->level,msg->sensor_value,msg->unit);
  }
  fprintf(file_ptr,"%s\n",ip_str);
  fflush(file_ptr);
  fclose(file_ptr);
  pthread_mutex_unlock(&logger_mutex); 
}


/*Unit Test to test various functions related to Temperature
 * Author: Harsimransingh Bindra & Yasir Aslam Shah
 * Advance Embedded System Design
 * Spring 2019
 * Definition: Test module to test various functionality for teh temperarture sensor.Includes the following functions:
 * Functions: Test_I2C_init(),Test_Read_Sensor_Celsius(),Test_Read_Sensor_Kelvin(),Test_Read_Sensor_Farenheit(),Test_Read_TLow(),
Test_Read_THigh(int file),Test_Read_Resolution(),Test_Read_Fault_Bits(),Test_Clear_ShutDown(),Test_Set_ShutDown(),
Test_Set_EM(),Test_Set_Conversion(),Test_Write_Configuration(),MY_ASSERT_NOT_EQUAL()
 * */

#ifndef TEST_TEMP_H
#define TEST_TEMP_H
//Standard Header files
#include <errno.h>
#include <stdlib.h>
#include <stdio.h>

//User Defined Header files
#include "temp.h"
#include "test_temp.h"


//Macros
#define status EXIT_FAILURE



//function defnition:
/* --------------------------------------------------------------------------*/
/**
 * @Synopsis  :Test function to test the I2C path and bus allocation to the slave(1)
 *
 * @Param file:File is used to allocate the I2C bus  and path to the slave
 *
 * @Returns   :returns exit status upon the success or failure of function
 */
/* ----------------------------------------------------------------------------*/
int Test_I2C_init_Temp(int file);
/* --------------------------------------------------------------------------*/
/**
 * @Synopsis  :test functiion to test the temperature sensor readaing in Celsius
 *
 * @Param file: File is used to allocate the path and bus to the I2C slave
 *
 * @Returns   :returns the exit status upon success or failure
 */
/* ----------------------------------------------------------------------------*/
int Test_Read_Sensor_Celsius(int file);
/* --------------------------------------------------------------------------*/
/**
 * @Synopsis  :test functiion to test the temperature sensor readaing in Kelvin
 *
 * @Param file: File is used to allocate the path and bus to the I2C slave
 *
 * @Returns   :returns the exit status upon success or failure
 */
/* ----------------------------------------------------------------------------*/
int Test_Read_Sensor_Kelvin(int file);
/* --------------------------------------------------------------------------*/
/**
 * @Synopsis  :test functiion to test the temperature sensor readaing in Farenheit
 *
 * @Param file: File is used to allocate the path and bus to the I2C slave
 *
 * @Returns   :returns the exit status upon success or failure
 */
/* ----------------------------------------------------------------------------*/
int Test_Read_Sensor_Farenheit(int file);
/* --------------------------------------------------------------------------*/
/**
 * @Synopsis  :test function to read the Tlow value from the TMP102 Sensor,TLOW 
 * stands for thethreshold low value for the alert to occur
 *
 * @Param file: File is used to allocate the path and bus to the I2C slave
 *
 * @Returns   :returns exit status upon success or failure
 */
/* ----------------------------------------------------------------------------*/
int Test_Read_TLow(int file);
/* --------------------------------------------------------------------------*/
/**
 * @Synopsis  :test function to read the THigh value from the TMP102 Sensor,
 * THigh stands for thethreshold low value for the alert to occur
 *
 * @Param file: File is used to allocate the path and bus to the I2C slave
 *
 * @Returns   :returns exit status upon success or failure
 */
/* ----------------------------------------------------------------------------*/
int Test_Read_THigh(int file);
/* --------------------------------------------------------------------------*/
/**
 * @Synopsis  :test function to configure the sensor resolution  value from the 
 * TMP102 Sensor,the sensor has a 12 bit and a 13 bit resolution
 *
 * @Param file: File is used to allocate the path and bus to the I2C slave
 *
 * @Returns   :returns exit status upon success or failure
 */
/* ----------------------------------------------------------------------------*/
int Test_Read_Resolution(int file);
/* --------------------------------------------------------------------------*/
/**
 * @Synopsis  :test function to configure the fault bits of sensor TMP102,a consecutive 
 * fault options of 1,2,4 and 6 are avaialble for the system to trigger the alert
 *
 * @Param file: File is used to allocate the path and bus to the I2C slave
 *
 * @Returns   :returns exit status upon success or failure
 */
/* ----------------------------------------------------------------------------*/
int Test_Read_Fault_Bits(int file);
/* --------------------------------------------------------------------------*/
/**
 * @Synopsis  :test function to configure the shutdown feature for the temperature
 * sensor, setting the shutdown bit enables the shutdown mode
 *
 * @Param file: File is used to allocate the path and bus to the I2C slave
 *
 * @Returns   :returns exit status upon success or failure
 */
/* ----------------------------------------------------------------------------*/
int Test_Clear_ShutDown(int file);
/* --------------------------------------------------------------------------*/
/**
 * @Synopsis  :test function to configure the shutdown feature for the temperature
 * sensor, clearing the shutdown bit disables the shutdown mode
 *
 * @Param file: File is used to allocate the path and bus to the I2C slave
 *
 * @Returns   :returns exit status upon success or failure
 */
/* ----------------------------------------------------------------------------*/
int Test_Set_ShutDown(int file);
/* --------------------------------------------------------------------------*/
/**
 * @Synopsis  :test function to configure the Extended Mode, extended mode allows 13 bit 
 * temperature reading allowing to read temperature above 128C
 *
 * @Param file: File is used to allocate the path and bus to the I2C slave
 *
 * @Returns   :returns exit status upon success or failure
 */
/* ----------------------------------------------------------------------------*/
int Test_Set_EM(int file);
/* --------------------------------------------------------------------------*/
/**
 * @Synopsis  :test function to configure the conversion rate for the sensor, 
 * conversion rate of 1Hz,4Hz and 8Hz are avaialable with 4Hz as default
 *
 * @Param file: File is used to allocate the path and bus to the I2C slave
 *
 * @Returns   :returns exit status upon success or failure
 */
/* ----------------------------------------------------------------------------*/
int Test_Set_Conversion(int file);
/* --------------------------------------------------------------------------*/
/**
 * @Synopsis  :test function to configure the write configuration register to 
 * enable and disable various features in TMP 102
 *
 * @Param file: File is used to allocate the path and bus to the I2C slave
 *
 * @Returns   :returns exit status upon success or failure
 */
/* ----------------------------------------------------------------------------*/
int Test_Write_Configuration(int file);
/* --------------------------------------------------------------------------*/
/**
 * @Synopsis  :test function to assert if the expected value is not equal to
 * the return value of the test function, and returns PASS if not equal to the 
 * EXIT_FAILURE or Fail if equal
 *
 * @Param result: the result contains the return value of the tested function 
 */
/* ----------------------------------------------------------------------------*/
//int MY_ASSERT_NOT_EQUAL(int result);
/* --------------------------------------------------------------------------*/
/**
 * @Synopsis  :test function to run all the test functions for temperature sensor
 *
 * @Param result: the result contains the return value of the tested function 
 */
/* ----------------------------------------------------------------------------*/
int main_temp(void);
#endif
/*Unit Test to test various functions related to Light Sensor APDS 9301
 * Author: Harsimransingh Bindra & Yasir Aslam Shah
 * Advance Embedded System Design
 * Spring 2019
 * Definition: Test module to test various functionality for the Light sensor.Includes the following functions:
 * Functions:MY_ASSERT_NOT_EQUAL(),Test_I2C_init(),Test_Turn_on_light_sensor(),Test_Check_PowerUp(),
Test_Read_Sensor_ID(),Test_Light_Sensor(),Test_Write_Interrupt(),Test_Read_Interrupt(),int Test_Status()
 * */

#ifndef TEST_LIGHT_H
#define TEST_LIGHT_H


//Standard Header Files
#include <errno.h>
#include <stdlib.h>
#include <stdio.h>

//User Defined Header Files
#include "light.h"
//macros
#define status EXIT_FAILURE



//Function Defnition:
/* --------------------------------------------------------------------------*/
/**
 * @Synopsis  :Test function to test the I2C path and bus allocation to the slave(2)
 *
 * @Param file:File is used to allocate the I2C bus  and path to the slave
 *
 * @Returns   :returns exit status upon the success or failure of function
 */
/* ----------------------------------------------------------------------------*/
int Test_I2C_init_Light(int file);
/* --------------------------------------------------------------------------*/
/**
 * @Synopsis  :Test function to test the powering up of Sensor by writing to the 
 * control register
 *
 * @Param file:File is used to allocate the I2C bus  and path to the slave
 *
 * @Returns   :returns exit status upon the success or failure of function
 */
/* ----------------------------------------------------------------------------*/
int Test_Turn_on_light_sensor(int file);
/* --------------------------------------------------------------------------*/
/**
 * @Synopsis  :Test function to check if the powering up the sensor is successfull
 * or not 
 *
 * @Param file:File is used to allocate the I2C bus  and path to the slave
 *
 * @Returns   :returns exit status upon the success or failure of function
 */
/* ----------------------------------------------------------------------------*/
int Test_Check_PowerUp(int file);
/* --------------------------------------------------------------------------*/
/**
 * @Synopsis  :Test function to read the sensor id of Light APDS 9301 to ensure the
 * I2C is working or not
 *
 * @Param file:File is used to allocate the I2C bus  and path to the slave
 *
 * @Returns   :returns exit status upon the success or failure of function
 */
/* ----------------------------------------------------------------------------*/
int Test_Read_Sensor_ID(int file,uint8_t SensorID);
/* --------------------------------------------------------------------------*/
/**
 * @Synopsis  :Test function to test the Light sensor and ensure if the values 
 * returned are correct and changes as per a change in ambient light around the
 * sensor
 *
 * @Param file:File is used to allocate the I2C bus  and path to the slave
 *
 * @Returns   :returns exit status upon the success or failure of function
 */
/* ----------------------------------------------------------------------------*/
int Test_Light_Sensor(int file);
/* --------------------------------------------------------------------------*/
/**
 * @Synopsis  :Test function to test the Light sensor by reading from the 16bit 
 * channels from the sensor
 *
 * @Param file:File is used to allocate the I2C bus  and path to the slave
 *
 * @Returns   :returns exit status upon the success or failure of function
 */
/* ----------------------------------------------------------------------------*/
int Test_Read_Data(int file);
/* --------------------------------------------------------------------------*/
/**
 * @Synopsis  :Test function to configure the interrupt by writing the High High, 
 * High Low, Low High and Low Low to the Sensor.
 *
 * @Param file:File is used to allocate the I2C bus  and path to the slave
 * @Param SensorID: is a paramameter to select the Light Sensor as SensorID:2
 *
 * @Returns   :returns exit status upon the success or failure of function
 */
/* ----------------------------------------------------------------------------*/
int Test_Write_Interrupt(int file, uint8_t SensorID);
/* --------------------------------------------------------------------------*/
/**
 * @Synopsis  :Test function to check if the values returned after writing the 
 * interrupt values are returned to be same after reading them back
 *
 * @Param file:File is used to allocate the I2C bus  and path to the slave
 *
 * @Returns   :returns exit status upon the success or failure of function
 */
/* ----------------------------------------------------------------------------*/
int Test_Read_Interrupt(int file);
/* --------------------------------------------------------------------------*/
/**
 * @Synopsis  :Test function to check the state of the system to be DARK or LIGHT 
 * based on the LUX values
 *
 * @Param file:File is used to allocate the I2C bus  and path to the slave
 *
 * @Returns   :returns exit status upon the success or failure of function
 */
/* ----------------------------------------------------------------------------*/
int Test_Status(int file);
/* --------------------------------------------------------------------------*/
/**
 * @Synopsis  :test function to assert if the expected value is not equal to
 * the return value of the test function, and returns PASS if not equal to the 
 * EXIT_FAILURE or Fail if equal
 *
 * @Param result: the result contains the return value of the tested function 
 */
/* ----------------------------------------------------------------------------*/
//int MY_ASSERT_NOT_EQUAL(int result);
/* --------------------------------------------------------------------------*/
/**
 * @Synopsis  :test function to run all the test functions for the light sensor
 *
 * @Param result: the result contains the return value of the tested function 
 */
/* ----------------------------------------------------------------------------*/
int main_light(void);
#endif
/* -.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.
* File Name : temperature.h
* Creation Date : 21-03-2019
* Last Modified : Wed 31 March 2019 00:02:56 PM MDT
* Created By : Harsimransingh and Yasir Shah
* Description: header file to contatainging function declaration for temperature
* 
* Functions:
*           -temp_main() function is first initializes the I2C bus then calls the 
             read_temperature function. 
*           -Read_Temperature() read function to read data from TMA102 sensor in C,K,F
*           -temperature_function() temperature pthread spawned calls this function 
             which initalises the temperature queue intializes the timer parameters and 
             starts a timer which logs temperature value periodically
*           -temperature_handler() Temperature timer handler which logs the temperature 
             periodically by addding new temperature value to the temp queue.
*           -temp_test() used for intial testing of the sensor
*           -temp_state() for knowing the current state
*           -Write_pointer_reg()
*           -Read_Tlow()
*           -Read_Thigh()
*           -Read_Resolution()
*           -Read_Fault_Bits()
*           -Set_ShutDown()
*           -Clear_ShutDown()
*           -Set_EM()
*           -Set_Conversion()
*           -Write_Configuration()
* References:
            -http://www.ti.com/lit/ds/symlink/tmp102.pdf
*           -https://www.sparkfun.com/products/13314  
*           
_._._._._._._._._._._._._._._._._._._._._.*/
//standard library
#ifndef TEMP_H
#define TEMP_H
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <errno.h>
#include <sys/ioctl.h>
#include <fcntl.h>
#include <unistd.h>

/*User defined libraries*/
#include "i2c.h"

//macros for temperature sensor
#define TMPSensor_Register 0x00
#define TMPSensor_Configuration 0x01
#define TMPSensor_TLow 0x02
#define TMPSensor_THigh 0x03
#define Mask 0b00010000
#define Minus_Correction 0xF800
#define Celsius 0.0625
#define KELVIN 273.5
#define FAREN 1.8
#define HEIT 32
#define TMPSensor_Conversion_8 0xC0
#define TMPSensor_Conversion_4 0x10
#define TMPSensor_Conversion_1 0x40
#define EM_Set 0x10
#define ShutDown_Set 0x6100
#define ShutDown_Clear 0x6000
#define Fault_Bits_4 0x7800
#define Fault_Bits_1 0x6000
#define Resolution 0x6000

//global variable 
int file;

/* -------------------------------*/
/**
 * @Synopsis temp_main() function is first initializes the I2C bus then calls the read_temperature function.
 *
 * @Param temp_value  used to return the temperature value to the callin function
 * @Param unit  used to indicate which is required by the calling function(Celcius, Kelvin or Farheniet)
 *
 * @Returns Exit status whether the temperature calculation was a success or not
 */
/* ---------------------------------*/
int temp_main(void);
/* -------------------------------*/
/**
 * @Synopsis  read function to read data from TMA102 sensor in C,K,F
 *
 * @Param file 
 * @Param unit used to indicate which is required by the calling function(Celcius, Kelvin or Farheniet)
 * @Param temp_value used to return the temperature value to the callin function
 *
 * @Returns Exit status whether the temperature calculation was a success or not
 */
/* ---------------------------------*/
int Read_Temperature(int file,int unit);
/* -------------------------------*/
/**
 * @Synopsis used to write the pointer register of TMP 102 sensor
 *
 * @Param file  to provide path for i2c bus
 * @Param value provides value to be written in the register
 *
 * @Returns exit status based on success or failure 
 */
/* ---------------------------------*/
int Write_pointer_reg(int file, uint8_t value);
/* -------------------------------*/
/**
 * @Synopsis reads the lower threshold value of TMP 102 sensor
 *
 * @Param file to provide path for i2c bus
 *
 * @Returns exit status based on success or failure
 */
/* ---------------------------------*/
int Read_TLow(int file);
/* -------------------------------*/
/**
 * @Synopsis reads the highe threshold value of TMP 102 sensor
 *
 * @Param file  to provide path for i2c bus
 *
 * @Returns exit status based on success or failure
 */
/* ---------------------------------*/
int Read_THigh(int file);
/* -------------------------------*/
/**
 * @Synopsis reads the current resolution on which the TMP 102 sensor is set
 *
 * @Param file  to provide path for i2c bus
 *
 * @Returns exit status based on success or failure
 */
/* ---------------------------------*/
int Read_Resolution(int file);
/* -------------------------------*/
/**
 * @Synopsis reads which fault bits are set currrently.
 *
 * @Param file to provide path for i2c bus
 *
 * @Returns exit status based on success or failure
 */
/* ---------------------------------*/
int Read_Fault_Bits(int file);
/* -------------------------------*/
/**
 * @Synopsis it sets the shutdown bit to reduce current consumption
 *
 * @Param file to provide path for i2c bus
 *
 * @Returns exit status based on success or failure
 */
/* ---------------------------------*/
int Set_ShutDown(int file);
/* -------------------------------*/
/**
 * @Synopsis clears the shutdown bit to make the sensor completely functional
 *
 * @Param file  to provide path for i2c bus
 *
 * @Returns exit status based on success or failure
 */
/* ---------------------------------*/
int Clear_ShutDown(int file);
/* -------------------------------*/
/**
 * @Synopsis`it changes the resolution of the sensor from 12 bits to 13 bits if wider temperature range is required
 *
 * @Param file to provide path for i2c bus
 *
 * @Returns exit status based on success or failure
 */
/* ---------------------------------*/
int Set_EM(int file);
/* -------------------------------*/
/**
 * @Synopsis it changes the read frequency of sensor between 1,4 and 8 Hz
 *
 * @Param file to provide path for i2c bus
 *
 * @Returns exit status based on success or failure
 */
/* ---------------------------------*/
int Set_Conversion(int file);
/* -------------------------------*/
/**
 * @Synopsis it writes the configuration register to access different sensor modes
 *
 * @Param file  to provide path for i2c bus
 *
 * @Returns exit status based on success or failure
 */
/* ---------------------------------*/
int Write_Configuration(int file);
#endif
/*Unit Test to test various unit tests
 * Author: Harsimransingh Bindra & Yasir Aslam Shah
 * Advance Embedded System Design
 * Spring 2019
 * Definition: Test module to test various functionality for the unit conversion .Includes the following functions:
 * Functions: test_main()
 * */

#ifndef _TEST_H
#define _TEST_H
//user defined files
#include "test_light.h"
#include "test_temp.h"
#include "test_conversion.h"

/* --------------------------------------------------------------------------*/
/**
 * @Synopsis  :Test main function , testing light, temp and conversion unit test
 *
 * @Returns   :returns EXIT status based on success or failure
 */
/* ----------------------------------------------------------------------------*/
//int test_main(void);
#endif
/*Unit Test to test various unit tests
 * Author: Harsimransingh Bindra & Yasir Aslam Shah
 * Advance Embedded System Design
 * Spring 2019
 * Definition: Test module to test various functionality for the unit conversion .Includes the following functions:
 * Functions: test_main()
 * */


#include "test_light.h"
#include "test_temp.h"
#include "test_conversion.h"

/* --------------------------------------------------------------------------*/
/**
 * @Synopsis  :Test main function , testing light, temp and conversion unit test
 *
 * @Returns   :returns EXIT status based on success or failure
 */
/* ----------------------------------------------------------------------------*/
int main(void)
{
  printf("**********TEST TEMPERATURE**********");
  main_temp();
  printf("**********TEST LIGHT**********");
  main_light();
  printf("**********TEST CONVERSION**********");
  main_conversion();
  printf("**********END**********");
  return EXIT_SUCCESS;
}
/* -.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.
* File Name : light.c
* Creation Date : 20-03-2019
* Last Modified : Wed 31 March 2019 00:09:00 PM MDT
* Created By : Harsimransingh and Yasir Shah
* Description: header file to contatainging function declaration for light sensors
* 
* Functions:
*           - Light_main() function is first initializes the I2C bus then calls the Read_Data function. 
*           - Read_Data() it calculates the lux value based on channel 1 and channel 2 values depending on the datasheet
*           - Read_Light_Sensor() it calculates the lux value based on channel 1 and channel 2 values depending on the datasheet 
*           - Turn_on_Light_sensor() turns the sensor on
*           - Check_PowerUp() to test if it successfully powers up the sensor
*           - light_function() light pthread spawned calls this function
*           - light_handler() light timer handler which logs the light value periodically by addding new light value to the temp queue.
*           - light_test() function to test the light sensor during initial startup
* References:
*           -https://www.broadcom.com/products/optical-sensors/ambient-light-photo-sensors/apds-9301
*           -https://learn.sparkfun.com/tutorials/apds-9301-sensor-hookup-guide/all         
_._._._._._._._._._._._._._._._._._._._._.*/
//include headers
#include<stdio.h>
#include<stdlib.h>
#include<stdint.h>
#include <math.h>
#include<fcntl.h>
#include<sys/ioctl.h>
#include<linux/i2c-dev.h>
#include<unistd.h>

//user defined header files
#include "i2c.h"
#include "light.h"

//global Variables
int file;
float Lux_Value;

int Light_main()
{
  //2 is for Sensor: Light
  int result = I2C_init(&file,2);
  if(result == EXIT_FAILURE)
  {
    printf("\nError: Sensor Initialization Failed!\n");
    return EXIT_FAILURE;
  }
  result = Turn_on_Light_sensor(file);
  if(result == EXIT_FAILURE)
  {
    printf("\nError: SensorII Reading Failed!\n");
    return EXIT_FAILURE;
  }
  
  result = Check_PowerUp(file);
  if(result == EXIT_FAILURE)
  {
    printf("\nError: SensorII Reading Failed!\n");
    return EXIT_FAILURE;
  }
  uint8_t SensorID;
  //usleep(500);
  result = Read_Sensor_ID(file,&SensorID);
  if(result == EXIT_FAILURE)
  {
    printf("\nError: SensorII Reading Failed!\n");
    return EXIT_FAILURE;
  }
  //printf("\nSensorID = %d\n",SensorID);

  result =Read_Light_Sensor(file);
  if(result == EXIT_FAILURE)
  {
    printf("\nError: SensorII Reading Failed!\n");
    return EXIT_FAILURE;
  }
  printf("\nLux is %f\n",Lux_Value);
 
  result =State(file,Lux_Value);
  if(result == EXIT_FAILURE)
  {
    printf("\nError: SensorII Status Failed!\n");
    return EXIT_FAILURE;
  }
  Enable_Interrupt_Control_Register(file);
  uint8_t in_value = 5;
  
  Write_Interrupt(file,&in_value);
  usleep(10000);
  Read_Interrupt(file);
  Disable_Interrupt_Control_Register(file);
  

  return EXIT_SUCCESS;
}

int State(int file,int LUX)
{
	if(LUX < 0)
	{
		return EXIT_FAILURE;
	}
	if(LUX >30)
	{
		printf("\nStatus: Light");
	}
	else printf("\nStatus: Dark");
	return EXIT_SUCCESS;

}
uint16_t Read_Data(int file, int flag,uint16_t *Final)
{
  uint8_t LSB,MSB;
  uint8_t address;
  if(flag == 1)
  {
    address =Command_Control | Data_Low0;
  }
  else if(flag ==2)
  {
    address =Command_Control | Data_Low1;
  }
    int result = I2C_Write_Byte(file,address);
  if(result == EXIT_FAILURE)
  {
    printf("\nError: SensorII Reading Failed!\n");
    return EXIT_FAILURE;
  }
  result = I2C_Read_Byte_Data(file,&LSB);
  if(result == EXIT_FAILURE)
  {
    printf("\nError: SensorII Reading Failed!\n");
    return EXIT_FAILURE;
  }
   if(flag == 1)
  {
    address =Command_Control | Data_High0;
  }
  else if(flag ==2)
  {
    address =Command_Control | Data_High1;
  }
  result = I2C_Write_Byte(file,address);
  if(result == EXIT_FAILURE)
  {
    printf("\nError: SensorII Reading Failed!\n");
    return EXIT_FAILURE;
  }
  result = I2C_Read_Byte_Data(file,&MSB);
  if(result == EXIT_FAILURE)
  {
    printf("\nError: SensorII Reading Failed!\n");
    return EXIT_FAILURE;
  }
  *Final = (MSB<<8)|(LSB);
  //printf("\nValue is %d\n",Final);
  return EXIT_SUCCESS;
}

//function to read lux values
int Read_Light_Sensor(int file)
{
  uint16_t temp;
  int result=Read_Data(file,1,&temp);
  if(result == EXIT_FAILURE)
  {
    printf("\nError: SensorII Reading Failed!\n");
    return EXIT_FAILURE;
  }
  float data0 =(float)temp;
  result =Read_Data(file,2,&temp);  
	if(result == EXIT_FAILURE)
  {
    printf("\nError: SensorII Reading Failed!\n");
    return EXIT_FAILURE;
  }
  float data1=(float)temp;
  if(data0 == 0)
	{
		perror("Error:Process Failed!");
		return EXIT_FAILURE;
	}
	
	float ADC= data1/data0;
  float power = pow(ADC,1.4);
	if(0 < ADC < 0.50)
	{
		Lux_Value = (0.0304 * data0) - (0.062 * data0 * power);
	}
	else if(0.50 < ADC < 0.61)
	{
		Lux_Value = (0.0224 * data0) - (0.031 * data1);
	}
	else if(0.61 < ADC < 0.80)
	{
		Lux_Value = (0.0128 * data0) - (0.0153 * data1);
	}
	else if(0.80 < ADC < 1.30)
	{
		Lux_Value = (0.00146 * data0) - (0.00112 * data1);
	}
	else
	{
		Lux_Value = 0;
	}
return EXIT_SUCCESS;

}

//function to check sensor is working by power up
int Turn_on_Light_sensor(int file)
{
  int result = write_control(file,Power_Up);
  if(result == EXIT_FAILURE)
  {
    printf("\nError: Sensor Initialization Failed!\n");
    return EXIT_FAILURE;
  }
  //Setting the Gain for the sensor
  //Integration time set to 402ms 
  result = write_timing(file,Set_Gain);
  if(result == EXIT_FAILURE)
  {
    printf("\nError: Sensor Initialization Failed!\n");
    return EXIT_FAILURE;
  }
  return EXIT_SUCCESS;
}

//function to see if power up is working
int Check_PowerUp(int file)
{
  int result = I2C_Write_Byte(file,Command_Control);
  if(result == EXIT_FAILURE)
  {
    printf("\nError: Sensor Initialization Failed!\n");
    return EXIT_FAILURE;
  }
  uint8_t buf[1];
  result = I2C_Read_Word(file,buf);
  if(result == EXIT_FAILURE)
  {
    printf("\nError: Sensor Initialization Failed!\n");
    return EXIT_FAILURE;
  }
  int value = buf[0];
  //printf("\nValue is %d %x\n",value,value);

  if(value == Power_Up_Return)
  {
    //printf("\nSensor Checkup Successfully!\n");
    return EXIT_SUCCESS;
  }
  else 
  {
    //printf("\nFailed!\n");
    return EXIT_FAILURE;
  }
  return EXIT_SUCCESS;
}

int Read_Sensor_ID(int file,uint8_t *data)
{
  uint8_t value = Command_Control | Sensor_ID;
  int result = I2C_Write_Byte(file,value);
  if(result == EXIT_FAILURE)
  {
    printf("\nError: Sensor_ID Write Failed!\n");
    return EXIT_FAILURE;
  }
  result = I2C_Read_Byte_Data(file,data);
  if(result == EXIT_FAILURE)
  {
    printf("\nError: Sensor_ID Write Failed!\n");
    return EXIT_FAILURE;
  }
  if(*data == 0x50)
  {
    //printf("\nSensorID Read Successfull!\n");
    return EXIT_SUCCESS;
  }
  return EXIT_SUCCESS;
}

int Read_Interrupt(int file)
{
  uint8_t value = Command_Control | Threshold_LL;
  int data[3];
  uint8_t *dat;
  
  int result = I2C_Read_Byte_Data(file,&value);
  if(result == EXIT_FAILURE)
  {
    printf("\nError: Sensor_ID 2Write Failed!\n");
    return EXIT_FAILURE;
  }
  //printf("\nValue in read%d", value); 
  
  value = Command_Control | Threshold_LH;
  result = I2C_Read_Byte_Data(file,&value);
  if(result == EXIT_FAILURE)
  {
    printf("\nError: Sensor_ID 2Write Failed!\n");
    return EXIT_FAILURE;
  }
  //printf("\nValue in read%d", value); 


  value = Command_Control | Threshold_HL;
  result = I2C_Read_Byte_Data(file,&value);
  if(result == EXIT_FAILURE)
  {
    printf("\nError: Sensor_ID 2Write Failed!\n");
    return EXIT_FAILURE;
  }
  //printf("\nValue in read%d", value); 

  
  value = Command_Control | Threshold_HH;
  result = I2C_Read_Byte_Data(file,&value);
  if(result == EXIT_FAILURE)
  {
    printf("\nError: Sensor_ID 2Write Failed!\n");
    return EXIT_FAILURE;
  }
  //printf("\nValue in read%d", value); 
  return EXIT_SUCCESS;
}

int Write_Interrupt(int file, uint8_t *in_value)
{
  uint8_t value = Command_Control | Threshold_LL;
  int data[3];
  
  int result = I2C_Write_Byte(file,value);
  if(result == EXIT_FAILURE)
  {
    printf("\nError: Sensor_ID Write Failed!\n");
    return EXIT_FAILURE;
  }
  data[0]=0x01;	
  result = I2C_Write_Byte(file,data[0]);
  

  value = Command_Control | Threshold_LH;
  result = I2C_Write_Byte(file,value);
  if(result == EXIT_FAILURE)
  {
    printf("\nError: Sensor_ID Write Failed!\n");
    return EXIT_FAILURE;
  }
  data[1]=0x02;	
  result = I2C_Write_Byte(file,data[1]);
  

  value = Command_Control | Threshold_HL;
  result = I2C_Write_Byte(file,value);
  if(result == EXIT_FAILURE)
  {
    printf("\nError: Sensor_ID Write Failed!\n");
    return EXIT_FAILURE;
  }
  data[2]=0x03;	
  result = I2C_Write_Byte(file,data[2]);
 
  value = Command_Control | Threshold_HH;
  result = I2C_Write_Byte(file,value);
  if(result == EXIT_FAILURE)
  {
    printf("\nError: Sensor_ID Write Failed!\n");
    return EXIT_FAILURE;
  }
  data[3]=0x04;	
  result = I2C_Write_Byte(file,data[3]);  
  //printf("\nData write is %d %d %d %d \n",data[0],data[1],data[2],data[3]);
  return EXIT_SUCCESS;
}

int Disable_Interrupt_Control_Register(int file)
{
  uint8_t value = Command_Control | Interrupt_Control_reg_Disable;
  int result = I2C_Write_Byte(file,value);
  if(result == EXIT_FAILURE)
  {
    printf("\nError: Interrupt disable Failed!\n");
    return EXIT_FAILURE;
  }
  value =0x23;
  result=I2C_Write_Byte(file,value);
  if(result == EXIT_FAILURE)
  {
    printf("\nError: Interrupt Enable Failed!\n");
    return EXIT_FAILURE;
  }

  int8_t data;
  result = I2C_Read_Byte_Data(file,&data);
  if(result == EXIT_FAILURE)
  {
    printf("\nError: Interrupt Disable Read Failed!\n");
    return EXIT_FAILURE;
  }
  //printf("\nRead Inter_Dis: %d %x\n",data,data);
  return EXIT_SUCCESS;
}


int Enable_Interrupt_Control_Register(int file)
{
  uint8_t value = Command_Control | Interrupt_Control_reg_Enable;
  int result = I2C_Write_Byte(file,value);
  if(result == EXIT_FAILURE)
  {
    printf("\nError: Interrupt Enable Failed!\n");
    return EXIT_FAILURE;
  }
  value =0x23;
  result=I2C_Write_Byte(file,value);
  if(result == EXIT_FAILURE)
  {
    printf("\nError: Interrupt Enable Failed!\n");
    return EXIT_FAILURE;
  }

  uint8_t data=0;
  result = I2C_Read_Byte_Data(file,&data);
  if(result == EXIT_FAILURE)
  {
    printf("\nError: Interrupt Disable Failed!\n");
    return EXIT_FAILURE;
  }
  //printf("\nRead Inter_En: %d %x\n",data,data);
  return EXIT_SUCCESS;

}


/* -.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.
* File Name : light.h
* Creation Date : 20-03-2019
* Last Modified : Wed 31 March 2019 00:07:26 PM MDT
* Created By : Harsimransingh and Yasir Shah
* Description: header file to contatainging function declaration for light sensors
* 
* Functions:
*           - Light_main() function is first initializes the I2C bus then calls the Read_Data function. 
*           - Read_Data() it calculates the lux value based on channel 1 and channel 2 values depending on the datasheet
*           - Read_Light_Sensor() it calculates the lux value based on channel 1 and channel 2 values depending on the datasheet 
*           - Turn_on_Light_sensor() turns the sensor on
*           - Check_PowerUp() to test if it successfully powers up the sensor
*           - light_function() light pthread spawned calls this function
*           - light_handler() light timer handler which logs the light value periodically by addding new light value to the temp queue.
* 
* References:
*           -https://www.broadcom.com/products/optical-sensors/ambient-light-photo-sensors/apds-9301
*           -https://learn.sparkfun.com/tutorials/apds-9301-sensor-hookup-guide/all         
_._._._._._._._._._._._._._._._._._._._._.*/

#ifndef LIGHT_H
#define LIGH_H
/*standard libraries*/
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <math.h>
#include <fcntl.h>
#include <sys/ioctl.h>
#include <linux/i2c-dev.h>
#include <unistd.h>

/*used defined libraries*/
#include "i2c.h"


//macros for Light Sensor APDS 9301
#define Power_Up 0x03
#define Power_Up_Return 0x33
#define Command_Control 0x80
#define Command_Reg 0x00
#define Timing_Reg 0x01
#define Data_Low0 0x0c
#define Data_High0 0x0D 
#define Data_Low1 0x0E
#define Data_High1 0x0F
#define Sensor_ID 0x0A
#define Set_Gain 0x12
#define Interrupt_Control_reg_Disable 0x06
#define Interrupt_Control_reg_Enable 0x06
#define Threshold_LL 0x02
#define Threshold_LH 0x03
#define Threshold_HL 0x04
#define Threshold_HH 0x05


//global variables
int file;
float Lux_Value;

/*functions*/

/* -------------------------------*/
/**
 * @Synopsis init function for light sensor to initialise and read
 *
 * @Param light_value to return the light value to the calling function
 *
 * @Returns exit status to indicate whether light value was read 
 * succcessfully from the sensor or an Error
 */
/* ---------------------------------*/
int Light_main();
/* -------------------------------*/
/**
 * @Synopsis check the current state of based on Lux values whether it is  
 * currently dark or light
 *
 * @Param file to provide path for i2c bus
 * @Param Lux input light value 
 *
 * @Returns exit status based on success or failure
 */
/* ---------------------------------*/
int State(int file, int Lux);
/* -------------------------------*/
/**
 * @Synopsis read function to read LUX Low and High Values 
 *
 * @Param file  to provide path for i2c bus
 * @Param flag  to select data channels -CH0(16 bits) CH1(16 bits)
 *
 * @Returns the light lux value
 */
/* ---------------------------------*/
uint16_t Read_Data(int file, int flag,uint16_t *Final);

//function to read lux value
/* -------------------------------*/
/**
 * @Synopsis it calculates the lux value based on channel 1 and channel 2 
 * values depending on the datasheet
 *
 * @Param file  to provide path for i2c bus 
 * @Param light_value to return the light value to the calling function
 *
 * @Returns returns the lux value based on datasheet calculation
 */
/* ---------------------------------*/
int Read_Light_Sensor(int file);

//function to check sensor is working by power up

/* -------------------------------*/
/**
 * @Synopsis firstly is powers up the light sensor then sets the gain for the sensor. 
 * Next the intergration time is set to 402ms based on Set_Gain macro. We change the 
 * control register value of the light sensor in this function
 *
 * @Param file to provide path for i2c bus
 *
 * @Returns exit status based on success or failure
 */
/* ---------------------------------*/
int Turn_on_Light_sensor(int file);

//function to see if power up is working
/* -------------------------------*/
/**
 * @Synopsis to test whether the control register was changed successfully or not
 *
 * @Param file to provide path for i2c bus
 *
 * @Returns exit status based on success or failure
 */
/* ---------------------------------*/
int Check_PowerUp(int file);

/* -------------------------------*/
/**
 * @Synopsis Read_Sensor_Id() reads the sensor ID connected to the I2C bus
 *
 * @Param file to provide path for i2c bus
 * @Param data it returns the sensor ID read.
 *
 * @Returns exit status based on success or failure
 */
/* ---------------------------------*/
int Read_Sensor_ID(int file,uint8_t *data);
/* -------------------------------*/
/**
 * @Synopsis To check if the interrupt registers are written successfully or not
 *
 * @Param file to provide path for i2c bus
 *
 * @Returns exit status based on success or failure
 */
/* ---------------------------------*/
int Read_Interrupt(int file);

/* -------------------------------*/
/**
 * @Synopsis To write the interrupt register of the light sensor
 *
 * @Param file to provide path for i2c bus
 * @Param in_value the value to be written on the interrupt register
 *
 * @Returns exit status based on success or failure
 */
/* ---------------------------------*/
int Write_Interrupt(int file, uint8_t *in_value);  
/* -------------------------------*/
/**
 * @Synopsis to disable the interrupts on the sensor
 *
 * @Param file to provide path for i2c bus
 *
 * @Returns exit status based on success or failure
 */
/* ---------------------------------*/
int Disable_Interrupt_Control_Register(int file);

/* -------------------------------*/
/**
 * @Synopsis to enable the interrupts for the light sensor
 *
 * @Param file to provide path for i2c bus
 *
 * @Returns exit status based on success or failure
 */
/* ---------------------------------*/
int Enable_Interrupt_Control_Register(int file);
#endif
/*I2C.c File
 * Author: Harsimransingh Bindra & Yasir Aslam Shah
 * Project 1
 * Advance Embedded System Design
 * Spring 2019
 * Description: This file contains functions to write/read to and from the slave.In this project TMP102 
 * (Temperature) and ADPS 9301(Light) sensors are used as the slave and the Beagle Bone Black acts as the 
 * master.The data is read or written to the slave as a bye or bytes or a word depending upon the slave 
 * register configuration.
 * The following file contains the following functions as: I2C_init(),write_control(),write_timing(),
 * Temp_Conversion(),I2C_Read_Byte_Data(),I2C_Read_Word(),I2C_Write_Byte,I2C_Write_Word,I2C_Write_Bytes.
 *
 * */

//Header files
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <errno.h>
#include <string.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <linux/i2c-dev.h>
#include <sys/ioctl.h>
#include <fcntl.h>
#include <unistd.h>

//User Defined Header Files 
#include "i2c.h"
#include "temp.h"
#include "light.h"


//init function to define the 2c path and allocate buses
int I2C_init(int *file,uint8_t sensor)
{
	int Slave_Address;	
	char *filename= "/dev/i2c-2";
	int temp_file;	
	temp_file=open(filename,O_RDWR);
	*file = temp_file;
  	if(temp_file < 0)
	{
		perror("Error :Cant Open File\n");
		return EXIT_FAILURE;  
	}
	
	if(sensor==Temper)
	{
		Slave_Address  = 0x48;
  }
	else if(sensor==Light)
	{	
		Slave_Address = 0x39;
	}
	if(ioctl(temp_file,I2C_SLAVE,Slave_Address)<0)
	{
		printf("Error:IOCTL Failed!\n");
		return EXIT_FAILURE;
	}
	return EXIT_SUCCESS;
}

//write control function to write to the control registers
uint8_t write_control(int file, uint8_t data)
{
  //writing to the command register
  uint8_t value = Command_Control | Command_Reg;
  int result = I2C_Write_Byte(file,value);
  if(result == EXIT_FAILURE)
  {
    //printf("\nError: Sensor Initialization Failed!\n");
    return EXIT_FAILURE;
  } 
  //writing to the control register
  result = I2C_Write_Byte(file,data);
  if(result == EXIT_FAILURE)
  {
    //printf("\nError: Sensor Initialization Failed!\n");
    return EXIT_FAILURE;
  }
  return EXIT_SUCCESS;
}

//write timing function to write to the timing registers
uint8_t write_timing(int file, uint8_t data)
{
  uint8_t value = Command_Control | Timing_Reg;
  int result = I2C_Write_Byte(file,value);
  if(result == EXIT_FAILURE)
  {
    //printf("\nError: Sensor Initialization Failed!\n");
    return EXIT_FAILURE;
  } 
  result = I2C_Write_Byte(file,data);
  if(result == EXIT_FAILURE)
  {
    //printf("\nError: Sensor Initialization Failed!\n");
    return EXIT_FAILURE;
  }
  return EXIT_SUCCESS;
}

//temperature conversion function to change fro Celsius
//Klevina and Farenheit Units as per User Demand
float Temp_Conversion(float temp, int unit)
{
  if(temp == 0)
  {
    return EXIT_FAILURE;
  }
  float temperature;
  if(unit == 2)
  {
    temperature = (temp* FAREN) + HEIT;
  }
  else if(unit ==3 )
  {
    temperature = temp + KELVIN;
  }
  return temperature;

}
//Read I2C data one single byte 
int I2C_Read_Byte_Data(int file , uint8_t *data)
{

	if(read(file,data,1) != 1)
	{
		//perror("Error :I2C BYTE Data Reading Failed!\n");
		return EXIT_FAILURE;
	}
	return EXIT_SUCCESS;
}
//Read I2C data one single word 
int I2C_Read_Word(int file , uint8_t *data)
{
	if(read(file,data,2)!=2)
	{
		//perror("Error :I2C WORD Data Reading Failed!\n");
		return EXIT_FAILURE;
	}
	return EXIT_SUCCESS;
}

//Write I2C data one single byte
int I2C_Write_Byte(int file , uint8_t data)
{
	if(write(file,&data,sizeof(data))!=1)
	{
		//perror("Error :I2C BYTE Data Write Failed!\n");
		return EXIT_FAILURE;
	}
	return EXIT_SUCCESS;
}

//Write I2C data one single word
int I2C_Write_Word(int file , uint32_t *data)
{
	if(write(file,data,3)!=3)
	{
		//perror("Error : :I2C WORD Data Write Failed!\n");
		return EXIT_FAILURE;
	}
	return EXIT_SUCCESS;
}

//Write I2C data with 16bit data
int I2C_Write_Bytes(int file , uint16_t * data)
{
	if(write(file,data,2)!=2)
	{
		//perror("Error : I2C BYTES Write Failed! \n");
		return EXIT_FAILURE;
	}
	return EXIT_SUCCESS;
}
/*I2C File
 * Author: Harsimransingh Bindra & Yasir Aslam Shah
 * Project 1
 * Advance Embedded System Design
 * Spring 2019
 *
 * Description: This file contains functions to write/read to and from the slave.In this 
 * project TMP102 (Temperature) and ADPS 9301(Light) sensors are used as the slave and the 
 * Beagle Bone Black acts as the master.The data is read or written to the slave as a bye 
 * or bytes or a word depending upon the slave register configuration.
 * The following file contains the following functions as: I2C_init(),write_control(),
 * write_timing(),Temp_Conversion(),I2C_Read_Byte_Data(),I2C_Read_Word(),I2C_Write_Byte,
 * I2C_Write_Word,I2C_Write_Bytes.
 *
 * */
#ifndef I2C_H
#define I2C_H

//header files
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <errno.h>
#include <string.h>
#include <linux/i2c-dev.h>
#include <sys/ioctl.h>
#include <fcntl.h>
#include <unistd.h>
#include <math.h>

//macros
#define Temper 1
#define Light 2

/* --------------------------------------------------------------------------*/
/**
 * @Synopsis  initializing function for I2C to define I2C path and connect and allocate the I2C Bus to teh slave
 *
 * @Param file - File provides the path to the I2C bus
 * @Param sensorv-Sensor parameter define if I2C is to be provided to the Light sensor or Temp sensor, 1:Temperature Sensor, 2:Light Sensor
 *
 * @Returns: Exit status based on success or failure   
 */
/* ----------------------------------------------------------------------------*/
int I2C_init(int *file, uint8_t sensor);
/* --------------------------------------------------------------------------*/
/**
 * @Synopsis  :Function to write control registers to the APDS Sensor,Like Powering ON the sensor
 *
 * @Param file: File provides the Path to the I2C bus
 * @Param data:Data provides the data to be written to the control register as , for powering up a data of 0x03 is written to the control register
 *
 * @Returns   :Exit Status based on success or failure
 */
/* ----------------------------------------------------------------------------*/
uint8_t write_control(int file, uint8_t data);
/* --------------------------------------------------------------------------*/
/**
 * @Synopsis  :Function to write to the timing registers for the APDS Light sensor.A value of 8 bits is written ORed with Command_Control(0x80) to write to the timing registers 
 *
 * @Param file: File provides the Path to teh I2C bus
 * @Param data: Data provids the value to be written to the timing registers
 *
 * @Returns   :Exit status based on success or failure
 */
/* ----------------------------------------------------------------------------*/
uint8_t write_timing(int file, uint8_t data);
/* --------------------------------------------------------------------------*/
/**
 * @Synopsis:Function to convert the temperature sensor values to different Units. Keelvin, to farenheit to Ceslius conversion is provided using this function  
 *
 * @Param temp: The Raw Temperature value read from the 16 bit register in the Temperature sensor
 * @Param unit: Unit provides the flexibility to user to select the final temperature unit,1:Ceslius, 2: Kelvin 3: Farenheit
 *
 * @Returns   :Exit status based on success or failure
 */
/* ----------------------------------------------------------------------------*/
float Temp_Conversion(float temp, int unit);
/* --------------------------------------------------------------------------*/
/**
 * @Synopsis  :I2C read function to read a byte of data from the I2C slave 
 *
 * @Param file: File provides the path to the I2C Bus
 * @Param data: Data pointer to store the 8bit data read from the slave 
 *
 * @Returns   :returns Exit status based on success or failure
 */
/* ----------------------------------------------------------------------------*/
int I2C_Read_Byte_Data(int file , uint8_t *data);
/* --------------------------------------------------------------------------*/
/**
 * @Synopsis  :Function to read 2 bytes from the I2C slave
 *
 * @Param file: file paramter to provide the path of I2C Bus
 * @Param data: Return exit statu
 *
 * @Returns :Return exit status based on success or exit 
 */
/* ----------------------------------------------------------------------------*/
int I2C_Read_Word(int file , uint8_t *data);
/* --------------------------------------------------------------------------*/
/**
 * @Synopsis  :Function to write to the I2C slave a data byte
 *
 * @Param file: file to provide the path of I2C bus
 * @Param data: 8 bit data to be written to the I2C slave
 *
 * @Returns   :exit status based on the success or failure
 */
/* ----------------------------------------------------------------------------*/
int I2C_Write_Byte(int file , uint8_t data);
/* --------------------------------------------------------------------------*/
/**
 * @Synopsis  :Function to write to the I2C slave a word data
 *
 * @Param file: fiel to provide the path of I2C bus
 * @Param data: 32 bit data to be written to the I2C slave
 *
 * @Returns : Exit status based on the success or failure   
 */
/* ----------------------------------------------------------------------------*/
int I2C_Write_Word(int file , uint32_t *data);
/* --------------------------------------------------------------------------*/
/**
 * @Synopsis  :Function to write to the I2C slave a data of two bytes
 *
 * @Param file: file to provide the path of I2C bus
 * @Param data: 16 bit data to be written to the I2C slave
 *
 * @Returns   :Exit status based on success or failure
 */
/* ----------------------------------------------------------------------------*/
int I2C_Write_Bytes(int file , uint16_t *data);
#endif


/*Unit Test to test various functions related to Temperature
 * Author: Harsimransingh Bindra & Yasir Aslam Shah
 * Advance Embedded System Design
 * Spring 2019
 * Definition: Test module to test various functionality for teh temperarture sensor.Includes the following functions:
 * Functions: Test_I2C_init(),Test_Read_Sensor_Celsius(),Test_Read_Sensor_Kelvin(),Test_Read_Sensor_Farenheit(),Test_Read_TLow(),
Test_Read_THigh(int file),Test_Read_Resolution(),Test_Read_Fault_Bits(),Test_Clear_ShutDown(),Test_Set_ShutDown(),
Test_Set_EM(),Test_Set_Conversion(),Test_Write_Configuration(),MY_ASSERT_NOT_EQUAL()
 * */

//Standard Header files
#include <errno.h>
#include <stdlib.h>
#include <stdio.h>

//User Defined Header files
#include "temp.h"
#include "test_temp.h"
#include "test_conversion.h"

//Macros
#define status EXIT_FAILURE


//function defnition:
/* --------------------------------------------------------------------------*/
/**
 * @Synopsis  :Test function to test the I2C path and bus allocation to the slave(1)
 *
 * @Param file:File is used to allocate the I2C bus  and path to the slave
 *
 * @Returns   :returns exit status upon the success or failure of function
 */
/* ----------------------------------------------------------------------------*/
int Test_I2C_init_Temp(int file)
{
	printf("\nTest I2C Init:");
	int result = I2C_init(&file,1);
	int result1=MY_ASSERT_NOT_EQUAL(result);

}
/* --------------------------------------------------------------------------*/
/**
 * @Synopsis  :test functiion to test the temperature sensor readaing in Celsius
 *
 * @Param file: File is used to allocate the path and bus to the I2C slave
 *
 * @Returns   :returns the exit status upon success or failure
 */
/* ----------------------------------------------------------------------------*/
int Test_Read_Sensor_Celsius(int file)
{
	printf("\nTest Read Celsius:");
	I2C_init(&file,1);	
	int result = Read_Temperature(file,1);
	int result1=MY_ASSERT_NOT_EQUAL(result);
  if(result1 == EXIT_FAILURE)
  {
    return EXIT_FAILURE;
  }
  return EXIT_SUCCESS;
}
/* --------------------------------------------------------------------------*/
/**
 * @Synopsis  :test functiion to test the temperature sensor readaing in Kelvin
 *
 * @Param file: File is used to allocate the path and bus to the I2C slave
 *
 * @Returns   :returns the exit status upon success or failure
 */
/* ----------------------------------------------------------------------------*/
int Test_Read_Sensor_Kelvin(int file)
{
	printf("\nTest Read Kelvin:");
	I2C_init(&file,1);	
	int result = Read_Temperature(file,2);
	int result1=MY_ASSERT_NOT_EQUAL(result);
  if(result1 == EXIT_FAILURE)
  {
    return EXIT_FAILURE;
  }
  return EXIT_SUCCESS;
}
/* --------------------------------------------------------------------------*/
/**
 * @Synopsis  :test functiion to test the temperature sensor readaing in Farenheit
 *
 * @Param file: File is used to allocate the path and bus to the I2C slave
 *
 * @Returns   :returns the exit status upon success or failure
 */
/* ----------------------------------------------------------------------------*/
int Test_Read_Sensor_Farenheit(int file)
{
	printf("\nTest Read Farenheit:");
	I2C_init(&file,1);	
	int result = Read_Temperature(file,3);
	int result1=MY_ASSERT_NOT_EQUAL(result);
  if(result1 == EXIT_FAILURE)
  {
    return EXIT_FAILURE;
  }
  return EXIT_SUCCESS;
}
/* --------------------------------------------------------------------------*/
/**
 * @Synopsis  :test function to read the Tlow value from the TMP102 Sensor,TLOW 
 * stands for thethreshold low value for the alert to occur
 *
 * @Param file: File is used to allocate the path and bus to the I2C slave
 *
 * @Returns   :returns exit status upon success or failure
 */
/* ----------------------------------------------------------------------------*/
int Test_Read_TLow(int file)
{
	printf("\nTest Read Sensor TLow:");
	I2C_init(&file,1);
	int result = Read_TLow(file);
	int result1=MY_ASSERT_NOT_EQUAL(result);
  if(result1 == EXIT_FAILURE)
  {
    return EXIT_FAILURE;
  }
  return EXIT_SUCCESS;
}
/* --------------------------------------------------------------------------*/
/**
 * @Synopsis  :test function to read the THigh value from the TMP102 Sensor,
 * THigh stands for thethreshold low value for the alert to occur
 *
 * @Param file: File is used to allocate the path and bus to the I2C slave
 *
 * @Returns   :returns exit status upon success or failure
 */
/* ----------------------------------------------------------------------------*/
int Test_Read_THigh(int file)
{
	printf("\nTest Read Sensor THigh:");
	I2C_init(&file,1);
	int result = Read_THigh(file);
	int result1=MY_ASSERT_NOT_EQUAL(result);
  if(result1 == EXIT_FAILURE)
  {
    return EXIT_FAILURE;
  }
  return EXIT_SUCCESS;
}
/* --------------------------------------------------------------------------*/
/**
 * @Synopsis  :test function to configure the sensor resolution  value from the 
 * TMP102 Sensor,the sensor has a 12 bit and a 13 bit resolution
 *
 * @Param file: File is used to allocate the path and bus to the I2C slave
 *
 * @Returns   :returns exit status upon success or failure
 */
/* ----------------------------------------------------------------------------*/
int Test_Read_Resolution(int file)
{
	printf("\nTest Read Resolution:");
	I2C_init(&file,1);
	int result = Read_Resolution(file);
	int result1=MY_ASSERT_NOT_EQUAL(result);
  if(result1 == EXIT_FAILURE)
  {
    return EXIT_FAILURE;
  }
  return EXIT_SUCCESS;
}
/* --------------------------------------------------------------------------*/
/**
 * @Synopsis  :test function to configure the fault bits of sensor TMP102,a consecutive 
 * fault options of 1,2,4 and 6 are avaialble for the system to trigger the alert
 *
 * @Param file: File is used to allocate the path and bus to the I2C slave
 *
 * @Returns   :returns exit status upon success or failure
 */
/* ----------------------------------------------------------------------------*/
int Test_Read_Fault_Bits(int file)
{
	printf("\nTest Read Fault Bits:");
	I2C_init(&file,1);
	int result = Read_Fault_Bits(file);
	int result1=MY_ASSERT_NOT_EQUAL(result);
  if(result1 == EXIT_FAILURE)
  {
    return EXIT_FAILURE;
  }
  return EXIT_SUCCESS;
}
/* --------------------------------------------------------------------------*/
/**
 * @Synopsis  :test function to configure the shutdown feature for the temperature
 * sensor, setting the shutdown bit enables the shutdown mode
 *
 * @Param file: File is used to allocate the path and bus to the I2C slave
 *
 * @Returns   :returns exit status upon success or failure
 */
/* ----------------------------------------------------------------------------*/
int Test_Clear_ShutDown(int file)
{
	printf("\nTest ShutDown Disable:");
	I2C_init(&file,1);
	int result = Clear_ShutDown(file);
	int result1=MY_ASSERT_NOT_EQUAL(result);
  if(result1 == EXIT_FAILURE)
  {
    return EXIT_FAILURE;
  }
  return EXIT_SUCCESS;
}
/* --------------------------------------------------------------------------*/
/**
 * @Synopsis  :test function to configure the shutdown feature for the temperature
 * sensor, clearing the shutdown bit disables the shutdown mode
 *
 * @Param file: File is used to allocate the path and bus to the I2C slave
 *
 * @Returns   :returns exit status upon success or failure
 */
/* ----------------------------------------------------------------------------*/
int Test_Set_ShutDown(int file)
{
	printf("\nTest Read Set ShutDown:");
	I2C_init(&file,1);
	int result = Set_ShutDown(file);
	int result1=MY_ASSERT_NOT_EQUAL(result);
  if(result1 == EXIT_FAILURE)
  {
    return EXIT_FAILURE;
  }
  return EXIT_SUCCESS;
}
/* --------------------------------------------------------------------------*/
/**
 * @Synopsis  :test function to configure the Extended Mode, extended mode allows 13 bit 
 * temperature reading allowing to read temperature above 128C
 *
 * @Param file: File is used to allocate the path and bus to the I2C slave
 *
 * @Returns   :returns exit status upon success or failure
 */
/* ----------------------------------------------------------------------------*/
int Test_Set_EM(int file)
{
	printf("\nTest Read Set Extended Mode:");
	I2C_init(&file,1);
	int result = Set_EM(file);
	int result1=MY_ASSERT_NOT_EQUAL(result);
  if(result1 == EXIT_FAILURE)
  {
    return EXIT_FAILURE;
  }
  return EXIT_SUCCESS;
}
/* --------------------------------------------------------------------------*/
/**
 * @Synopsis  :test function to configure the conversion rate for the sensor, 
 * conversion rate of 1Hz,4Hz and 8Hz are avaialable with 4Hz as default
 *
 * @Param file: File is used to allocate the path and bus to the I2C slave
 *
 * @Returns   :returns exit status upon success or failure
 */
/* ----------------------------------------------------------------------------*/
int Test_Set_Conversion(int file)
{
	printf("\nTest Read Set Conversion:");
	I2C_init(&file,1);
	int result = Set_Conversion(file);
	int result1=MY_ASSERT_NOT_EQUAL(result);
  if(result1 == EXIT_FAILURE)
  {
    return EXIT_FAILURE;
  }
  return EXIT_SUCCESS;
}
/* --------------------------------------------------------------------------*/
/**
 * @Synopsis  :test function to configure the write configuration register to 
 * enable and disable various features in TMP 102
 *
 * @Param file: File is used to allocate the path and bus to the I2C slave
 *
 * @Returns   :returns exit status upon success or failure
 */
/* ----------------------------------------------------------------------------*/
int Test_Write_Configuration(int file)
{
	printf("\nTest Write Configuration:");
	I2C_init(&file,1);
	int result = Write_Configuration(file);
	int result1=MY_ASSERT_NOT_EQUAL(result);
  if(result1 == EXIT_FAILURE)
  {
    return EXIT_FAILURE;
  }
  return EXIT_SUCCESS;
}
/* --------------------------------------------------------------------------*/
/**
 * @Synopsis  :test function to assert if the expected value is not equal to
 * the return value of the test function, and returns PASS if not equal to the 
 * EXIT_FAILURE or Fail if equal
 *
 * @Param result: the result contains the return value of the tested function 
 */
/* ----------------------------------------------------------------------------*/
/*int MY_ASSERT_NOT_EQUAL(int result)
{
	if(result != status)
	{
		printf("Pass!\n");
		return EXIT_SUCCESS;
	}
	else 
  {
    printf("Fail!");
    return EXIT_FAILURE;
  }
}*/
/* --------------------------------------------------------------------------*/
/**
 * @Synopsis  :test function to run all the test functions for temperature sensor
 *
 * @Param result: the result contains the return value of the tested function 
 */
/* ----------------------------------------------------------------------------*/
int main_temp(void)
{
	int file;

int res = Test_I2C_init_Temp(file);
  res = Test_Read_Sensor_Celsius(file);
  res = Test_Read_Sensor_Kelvin(file);	
  res = Test_Read_Sensor_Farenheit(file);

  res = Test_Write_Configuration(file);
  res = Test_Read_TLow(file);

  res = Test_Read_THigh(file);

  res = Test_Read_Resolution(file);
  res = Test_Read_Fault_Bits(file);
  res = Test_Clear_ShutDown(file);
  res = Test_Set_ShutDown(file);
  res = Test_Set_EM(file);

  res = Test_Set_Conversion(file);

  res = Test_Write_Configuration(file);
  
  return 0;
}
/* -.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.
* File Name : temperature.h
* Creation Date : 21-03-2019
* Last Modified : Wed 31 March 2019 00:02:56 PM MDT
* Created By : Harsimransingh and Yasir Shah
* Description: header file to contatainging function declaration for temperature
* 
* Functions:
*           -temp_main() function is first initializes the I2C bus then calls the 
	     read_temperature function. 
*           -Read_Temperature() read function to read data from TMA102 sensor in C,K,F
*           -temperature_function() temperature pthread spawned calls this function which 
             initalises the temperature queue intializes the timer parameters and starts 
             a timer which logs temperature value periodically
*           -temperature_handler() Temperature timer handler which logs the temperature 
             periodically by addding new temperature value to the temp queue.
*           -temp_test() used for intial testing of the sensor
*           -temp_state() for knowing the current state
*           -Write_pointer_reg()
*           -Read_Tlow()
*           -Read_Thigh()
*           -Read_Resolution()
*           -Read_Fault_Bits()
*           -Set_ShutDown()
*           -Clear_ShutDown()
*           -Set_EM()
*           -Set_Conversion()
*           -Write_Configuration()
* References:
            -http://www.ti.com/lit/ds/symlink/tmp102.pdf
*           -https://www.sparkfun.com/products/13314  
*           
_._._._._._._._._._._._._._._._._._._._._.*/

//user defined library
#include "temp.h"
#include "i2c.h"

int val;
int temp_main(void)
{
  int unit=1;
  int result=I2C_init(&file,1);
  if(result == EXIT_FAILURE)
  {
    printf("\nError: Sensor Initialization Failed!\n");
    return EXIT_FAILURE;
  }
  result = Read_Temperature(file,1);
  if(result == EXIT_FAILURE)
  {
    printf("\nError: Sensor Reading Failed!\n");
    return EXIT_FAILURE;
  }
  result = Read_Temperature(file,2);
  if(result == EXIT_FAILURE)
  {
    printf("\nError: Sensor Reading Failed!\n");
    return EXIT_FAILURE;
  } 
  result = Read_Temperature(file,3);
  if(result == EXIT_FAILURE)
  {
    printf("\nError: Sensor Reading Failed!\n");
    return EXIT_FAILURE;
  }
return EXIT_SUCCESS;

}


//read function to read data from TMA102 sensor in C,K,F
int Read_Temperature(int file,int unit)
{

  int result=I2C_Write_Byte(file,TMPSensor_Register);
  if(result == EXIT_FAILURE)
  {
    perror("\nError: Failed to Write!\n");
    return EXIT_FAILURE;
  }
  usleep(500);
  char buffer[1];
  result=I2C_Read_Word(file,buffer);
  if(result == EXIT_FAILURE)
  {
    perror("\nError: Failed to Write!\n");
    return EXIT_FAILURE;
  } 
	
  int temperature;
  temperature = ((buffer[0]) << 8) | (buffer[1]);
  temperature >>= 4;

  //correcting the signed bit
	if (temperature & (1 << 11))
  {
    temperature = temperature | Minus_Correction;
  }
  float  final_temperature= temperature * Celsius;
  if(unit == 1)
  {
    final_temperature= temperature * Celsius;
	  printf("Temp:%02fC  ", final_temperature);
  }
  else if(unit == 2)
  {
    float final_temperature_F = Temp_Conversion(final_temperature,unit);
    printf("Temp:%02fF  ", final_temperature_F);

  }
  else if(unit == 3)
  {
    float final_temperature_K = Temp_Conversion(final_temperature,unit);
    printf("Temp:%02fK  ", final_temperature_K);
 }
    usleep(10);
  return EXIT_SUCCESS;
}

int Write_Pointer_Reg(int file, uint8_t value)
{
	int result = I2C_Write_Byte(file,value);
  	if(result == EXIT_FAILURE)
  	{
    		perror("\nError: Failed to Write to Pointer!\n");
    		return EXIT_FAILURE;
  	}
}

int Read_TLow(int file)
{
  char buffer[1];	
  int result = I2C_Write_Byte(file,TMPSensor_TLow);
  if(result == EXIT_FAILURE)
  {
    perror("\nError: Failed to Write!\n");
    return EXIT_FAILURE;
  }
  result = I2C_Read_Byte_Data(file,buffer);
  if(result == EXIT_FAILURE)
  {
    perror("\nError: Failed to Write!\n");
    return EXIT_FAILURE;
  }
  int temperature=0;
  Write_Configuration(file);
  float temp = 0.0;

  if(val == 1)
  {
  	temperature = ((buffer[0]) << 8) | (buffer[1]);
  	temperature >>= 3;
	temp = temperature * Celsius;
  }
  else 
  {
	temperature = ((buffer[0]) << 8) | (buffer[1]);
  	temperature >>= 4; 
  	temp = temperature * Celsius ;
  }	
  printf("Read Value TLow is %f ",temp); 
 
  return EXIT_SUCCESS;
}

int Read_THigh(int file)
{
  int result = I2C_Write_Byte(file,TMPSensor_THigh);
  if(result == EXIT_FAILURE)
  {
    perror("\nError: Failed to Write!\n");
    return EXIT_FAILURE;
  }
  uint8_t buffer[1];
  result = I2C_Read_Word(file,buffer);
  if(result == EXIT_FAILURE)
  {
    perror("\nError: Failed to Write!\n");
    return EXIT_FAILURE;
  }
  float temp= 0.0;
  int temperature = 0;
  Write_Configuration(file);
  if(val == 1)
  {
  	temperature = ((buffer[0]) << 8) | (buffer[1]);
  	temperature >>= 3; 
 	temp = temperature * Celsius ;
  }
  else 
  {
	temperature = ((buffer[0]) << 8) | (buffer[1]);
  	temperature >>= 4; 	
  	temp = temperature * Celsius ;
  }	
  printf("Read Value THigh is %f ",temp);
  return EXIT_SUCCESS;
}

int Read_Resolution(int file)
{
  uint16_t value = Resolution;
  int result=I2C_Write_Bytes(file,&value);
  if(result == EXIT_FAILURE)
  {
    perror("\nError: Failed to Write!\n");
    return EXIT_FAILURE;
  }
  char buffer[1];
  result = I2C_Read_Word(file,buffer);
  if(result == EXIT_FAILURE)
  {
    perror("\nError: Failed to Read!\n");
    return EXIT_FAILURE;
  }
  unsigned char MSB =buffer[0];
  MSB = MSB & 0b01100000;
  if(MSB == 0x13)
  {
	printf("Resolution at 12 ");
  }
  else 
  {
 	printf("Resolutiion at 13 ");
  }
  return EXIT_SUCCESS;
}

int Read_Fault_Bits(int file)
{
  uint16_t value = Fault_Bits_4;	
 
  int result=I2C_Write_Bytes(file,&value);
  if(result == EXIT_FAILURE)
  {
    perror("\nError: Failed to Write!\n");
    return EXIT_FAILURE;
  }
  char buffer[1];
  result = I2C_Read_Word(file,buffer);
  if(result == EXIT_FAILURE)
  {
    perror("\nError: Failed to Read!\n");
    return EXIT_FAILURE;
  }
  unsigned char MSB =buffer[0];
  unsigned char LSB= buffer[1];
  //MSB = MSB & 0b01111000;
  if(MSB ==0x13)
  {
	printf("Fault Bits 4 ");
  }
  else 
  {
 	printf("Fault Bits less than 4 ");
  }
  return EXIT_SUCCESS;
}
int Clear_ShutDown(int file)
{
  uint16_t value =ShutDown_Clear;	
  int result=Write_Pointer_Reg(file,value);
  if(result == EXIT_FAILURE)
  {
    perror("\nError: Failed to Write!\n");
    return EXIT_FAILURE;
  }
  char buffer[1];
  result = I2C_Read_Word(file,buffer);
  if(result == EXIT_FAILURE)
  {
    perror("\nError: Failed to Read!\n");
    return EXIT_FAILURE;
  }
  unsigned char MSB =buffer[0];
  //MSB = MSB & 0b011000001;
  
  if(MSB == 0x60)
  {
	printf("ShutDown Mode Enable ");
  }
  else 
  {
 	printf("ShutDown Mode Disable ");
  }
  return EXIT_SUCCESS;
}
int Set_ShutDown(int file)
{
  uint16_t value =ShutDown_Set;	
  int result=Write_Pointer_Reg(file,value);
  if(result == EXIT_FAILURE)
  {
    perror("\nError: Failed to Write!\n");
    return EXIT_FAILURE;
  }
  char buffer[1];
  result = I2C_Read_Word(file,buffer);
  if(result == EXIT_FAILURE)
  {
    perror("\nError: Failed to Read!\n");
    return EXIT_FAILURE;
  }
  unsigned char MSB =buffer[0];
  
  if(MSB == 0x13)
  {
	  printf("ShutDown Mode Enable ");
  }
  else 
  {
 	  printf("ShutDown Mode Disable ");
  }
  return EXIT_SUCCESS;
}
int Set_EM(int file)
{
  uint16_t value =EM_Set;	
  int result=Write_Pointer_Reg(file,value);
  if(result == EXIT_FAILURE)
  {
    perror("\nError: Failed to Write!\n");
    return EXIT_FAILURE;
  }
  char buffer[1];
  result = I2C_Read_Word(file,buffer);
  if(result == EXIT_FAILURE)
  {
    perror("\nError: Failed to Read!\n");
    return EXIT_FAILURE;
  }
  unsigned char LSB =buffer[1];
  
  if(LSB ==0x10)
  {
	  printf("Extended Mode 13 Bit ");
  }
  else 
  {
 	  printf("Extended Mode 12 Bit ");
  }
  return EXIT_SUCCESS;
}
int Set_Conversion(int file)
{
  uint16_t value =TMPSensor_Conversion_8;	
  int result=Write_Pointer_Reg(file,value);
  if(result == EXIT_FAILURE)
  {
    perror("\nError: Failed to Write_Convert!\n");
    return EXIT_FAILURE;
  }
  char buffer[1];
  result = I2C_Read_Word(file,buffer);
  if(result == EXIT_FAILURE)
  {
    perror("\nError: Failed to Read_Convert!\n");
    return EXIT_FAILURE;
  }
  unsigned char LSB =buffer[1];
  
  if(LSB == 0x40)
  {
  	printf("1Hz Frequency set! ");
  }
  else if(LSB == 0xc0)
  {
  	printf("8Hz Frequency set! ");
  }
  else
  {
  	printf("4Hz Frequency Set by Default ");
  }
  return EXIT_SUCCESS;
}

int Write_Configuration(int file)
{
  uint16_t value =TMPSensor_Configuration;	
  int result=Write_Pointer_Reg(file,value);
  if(result == EXIT_FAILURE)
  {
    perror("\nError: Failed to Write!\n");
    return EXIT_FAILURE;
  }
  char buffer[1];
  result = I2C_Read_Word(file,buffer);
  if(result == EXIT_FAILURE)
  {
    perror("\nError: Failed to Read!\n");
    return EXIT_FAILURE;
  }
  unsigned char LSB =buffer[1];
  LSB = LSB & Mask;
  if(LSB ==0x10)
  {
  	val =1;
  }
  else val =0;

  return EXIT_SUCCESS;
}
/*Unit Test to test various functions related to Light Sensor APDS 9301
 * Author: Harsimransingh Bindra & Yasir Aslam Shah
 * Advance Embedded System Design
 * Spring 2019
 * Definition: Test module to test various functionality for the Light sensor.Includes the following functions:
 * Functions:MY_ASSERT_NOT_EQUAL(),Test_I2C_init(),Test_Turn_on_light_sensor(),Test_Check_PowerUp(),
Test_Read_Sensor_ID(),Test_Light_Sensor(),Test_Write_Interrupt(),Test_Read_Interrupt(),int Test_Status()
 * */

//Standard Header Files
#include <errno.h>
#include <stdlib.h>
#include <stdio.h>

//User Defined Header Files
#include "light.h"
#include "test_light.h"
#include "test_conversion.h"

//macros
#define status EXIT_FAILURE


//Function Defnition:
/* --------------------------------------------------------------------------*/
/**
 * @Synopsis  :Test function to test the I2C path and bus allocation to the slave(2)
 *
 * @Param file:File is used to allocate the I2C bus  and path to the slave
 *
 * @Returns   :returns exit status upon the success or failure of function
 */
/* ----------------------------------------------------------------------------*/
int Test_I2C_init_Light(int file)
{
	printf("\nTest I2C Init:");
	int result = I2C_init(&file,2);
	int result1=MY_ASSERT_NOT_EQUAL(result);
  if(result1 == EXIT_FAILURE)
  {
    return EXIT_FAILURE;
  }
  return EXIT_SUCCESS;
}
/* --------------------------------------------------------------------------*/
/**
 * @Synopsis  :Test function to test the powering up of Sensor by writing to the 
 * control register
 *
 * @Param file:File is used to allocate the I2C bus  and path to the slave
 *
 * @Returns   :returns exit status upon the success or failure of function
 */
/* ----------------------------------------------------------------------------*/
int Test_Turn_on_light_sensor(int file)
{
	printf("\nTest Turn Sensor ON:");
	I2C_init(&file,2);	
	int result = Turn_on_Light_sensor(file);
    int result1=MY_ASSERT_NOT_EQUAL(result);
  if(result1 == EXIT_FAILURE)
  {
    return EXIT_FAILURE;
  }
  return EXIT_SUCCESS;
}
/* --------------------------------------------------------------------------*/
/**
 * @Synopsis  :Test function to check if the powering up the sensor is successfull
 * or not 
 *
 * @Param file:File is used to allocate the I2C bus  and path to the slave
 *
 * @Returns   :returns exit status upon the success or failure of function
 */
/* ----------------------------------------------------------------------------*/
int Test_Check_PowerUp(int file)
{
	printf("\nTest Check Power Up:");
	I2C_init(&file,2);
	Turn_on_Light_sensor(file);
	int result = Check_PowerUp(file);
	int result1=MY_ASSERT_NOT_EQUAL(result);
  if(result1 == EXIT_FAILURE)
  {
    return EXIT_FAILURE;
  }
  return EXIT_SUCCESS;
}
/* --------------------------------------------------------------------------*/
/**
 * @Synopsis  :Test function to read the sensor id of Light APDS 9301 to ensure the
 * I2C is working or not
 *
 * @Param file:File is used to allocate the I2C bus  and path to the slave
 *
 * @Returns   :returns exit status upon the success or failure of function
 */
/* ----------------------------------------------------------------------------*/
int Test_Read_Sensor_ID(int file,uint8_t SensorID)
{
	printf("\nTest Read Sensor ID:");
	I2C_init(&file,2);
	Turn_on_Light_sensor(file);
	int result = Read_Sensor_ID(file,&SensorID);
	int result1=MY_ASSERT_NOT_EQUAL(result);
  if(result1 == EXIT_FAILURE)
  {
    return EXIT_FAILURE;
  }
  return EXIT_SUCCESS;
}
/* --------------------------------------------------------------------------*/
/**
 * @Synopsis  :Test function to test the Light sensor and ensure if the values 
 * returned are correct and changes as per a change in ambient light around the
 * sensor
 *
 * @Param file:File is used to allocate the I2C bus  and path to the slave
 *
 * @Returns   :returns exit status upon the success or failure of function
 */
/* ----------------------------------------------------------------------------*/
int Test_Light_Sensor(int file)
{
	printf("\nTest Light Sensor:");
	I2C_init(&file,2);
	Turn_on_Light_sensor(file);
	int result = Read_Light_Sensor(file);
	int result1=MY_ASSERT_NOT_EQUAL(result);
  if(result1 == EXIT_FAILURE)
  {
    return EXIT_FAILURE;
  }
  return EXIT_SUCCESS;
}
/* --------------------------------------------------------------------------*/
/**
 * @Synopsis  :Test function to test the Light sensor by reading from the 16bit 
 * channels from the sensor
 *
 * @Param file:File is used to allocate the I2C bus  and path to the slave
 *
 * @Returns   :returns exit status upon the success or failure of function
 */
/* ----------------------------------------------------------------------------*/
int Test_Read_Data(int file)
{
	printf("\nTest Light Sensor Read Data:");
	I2C_init(&file,2);
	Turn_on_Light_sensor(file);
  uint16_t temp;
	int result = Read_Data(file,1,&temp);
	int result1=MY_ASSERT_NOT_EQUAL(result);
  if(result1 == EXIT_FAILURE)
  {
    return EXIT_FAILURE;
  }
  return EXIT_SUCCESS;
}
/* --------------------------------------------------------------------------*/
/**
 * @Synopsis  :Test function to configure the interrupt by writing the High High, 
 * High Low, Low High and Low Low to the Sensor.
 *
 * @Param file:File is used to allocate the I2C bus  and path to the slave
 * @Param SensorID: is a paramameter to select the Light Sensor as SensorID:2
 *
 * @Returns   :returns exit status upon the success or failure of function
 */
/* ----------------------------------------------------------------------------*/
int Test_Write_Interrupt(int file, uint8_t SensorID)
{
	printf("\nTest Write Interrupt:");
	I2C_init(&file,2);
	Turn_on_Light_sensor(file);
	int result = Write_Interrupt(file,&SensorID);
	int result1=MY_ASSERT_NOT_EQUAL(result);
  if(result1 == EXIT_FAILURE)
  {
    return EXIT_FAILURE;
  }
  return EXIT_SUCCESS;
}
/* --------------------------------------------------------------------------*/
/**
 * @Synopsis  :Test function to check if the values returned after writing the 
 * interrupt values are returned to be same after reading them back
 *
 * @Param file:File is used to allocate the I2C bus  and path to the slave
 *
 * @Returns   :returns exit status upon the success or failure of function
 */
/* ----------------------------------------------------------------------------*/
int Test_Read_Interrupt(int file)
{
	printf("\nTest Read Interrupt:");
	I2C_init(&file,2);
	Turn_on_Light_sensor(file);
	int result = Read_Interrupt(file);
  int result1=MY_ASSERT_NOT_EQUAL(result);
  if(result1 == EXIT_FAILURE)
  {
    return EXIT_FAILURE;
  }
  return EXIT_SUCCESS;
}
/* --------------------------------------------------------------------------*/
/**
 * @Synopsis  :Test function to check the state of the system to be DARK or LIGHT 
 * based on the LUX values
 *
 * @Param file:File is used to allocate the I2C bus  and path to the slave
 *
 * @Returns   :returns exit status upon the success or failure of function
 */
/* ----------------------------------------------------------------------------*/
int Test_Status(int file)
{
	printf("\nTest Status:");
	I2C_init(&file,2);
	int result = State(file,Lux_Value);
	int result1=MY_ASSERT_NOT_EQUAL(result);
  if(result1 == EXIT_FAILURE)
  {
    return EXIT_FAILURE;
  }
  return EXIT_SUCCESS;
}
/* --------------------------------------------------------------------------*/
/**
 * @Synopsis  :test function to assert if the expected value is not equal to
 * the return value of the test function, and returns PASS if not equal to the 
 * EXIT_FAILURE or Fail if equal
 *
 * @Param result: the result contains the return value of the tested function 
 */
/* ----------------------------------------------------------------------------*/
/*int MY_ASSERT_NOT_EQUAL(int result)
{
	if(result != status)
	{
		printf("Pass!\n");
		return EXIT_SUCCESS;
	}
	else
  {
    printf("Fail!");
    return EXIT_FAILURE;
  }
}*/
/* --------------------------------------------------------------------------*/
/**
 * @Synopsis  :test function to run all the test functions for the light sensor
 *
 * @Param result: the result contains the return value of the tested function 
 */
/* ----------------------------------------------------------------------------*/
int main_light(void)
{
	int file;
	uint8_t SensorID;
	uint8_t in_value;

	Test_I2C_init_Light(file);
  Test_Turn_on_light_sensor(file);
  Test_Check_PowerUp(file);
  Test_Read_Sensor_ID(file,SensorID);
  Test_Light_Sensor(file);

  Test_Status(file);

  Test_Write_Interrupt(file,SensorID);

  Test_Read_Interrupt(file);
  
  return EXIT_SUCCESS;
}

/*Unit Test to test various functions related to temperature conversion
 * Author: Harsimransingh Bindra & Yasir Aslam Shah
 * Advance Embedded System Design
 * Spring 2019
 * Definition: Test module to test various functionality for the unit conversion .Includes the following functions:
 * Functions:Test_I2C_init(int file),Test_Read_Temperature_Celsius(int file),Test_Read_Temperature_Kelvin(int file),
 * Test_Read_Temperature_Farenheit(int file),MY_ASSERT_NOT_EQUAL(int result)
 * */

//Standard Library header
#include <errno.h>
#include <stdlib.h>
#include <stdio.h>

//User Defined Header
#include "temp.h"
#include "i2c.h"
#include "test_conversion.h"

//macros
#define status EXIT_FAILURE


//Function Defnition:
/* --------------------------------------------------------------------------*/
/**
 * @Synopsis  :Test function to test the I2C path and bus allocation to the slave(2)
 *
 * @Param file:File is used to allocate the I2C bus  and path to the slave
 *
 * @Returns   :returns exit status upon the success or failure of function
 */
/* ----------------------------------------------------------------------------*/
int Test_I2C_init_Conversion(int file)
{
	printf("\nTest I2C Init:");
	int result = I2C_init(&file,1);
	MY_ASSERT_NOT_EQUAL(result);
	int result1=MY_ASSERT_NOT_EQUAL(result);
  if(result1 == EXIT_FAILURE)
  {
    return EXIT_FAILURE;
  }
  return EXIT_SUCCESS;
}
/* --------------------------------------------------------------------------*/
/**
 * @Synopsis  :test functiion to test the temperature sensor readaing in Celsius
 *
 * @Param file: File is used to allocate the path and bus to the I2C slave
 *
 * @Returns   :returns the exit status upon success or failure
 */
/* ----------------------------------------------------------------------------*/
int Test_Read_Temperature_Celsius(int file)
{
	printf("\nTest Temperature in Celsius:");
	I2C_init(&file,1);	
	int result = Read_Temperature(file,1);
	int result1=MY_ASSERT_NOT_EQUAL(result);
  if(result1 == EXIT_FAILURE)
  {
    return EXIT_FAILURE;
  }
  return EXIT_SUCCESS;
}
/* --------------------------------------------------------------------------*/
/**
 * @Synopsis  :test functiion to test the temperature sensor readaing in Kelvin
 *
 * @Param file: File is used to allocate the path and bus to the I2C slave
 *
 * @Returns   :returns the exit status upon success or failure
 */
/* ----------------------------------------------------------------------------*/
int Test_Read_Temperature_Kelvin(int file)
{
	printf("\nTest Temperature in Kelvin:");
	I2C_init(&file,1);	
	int result = Read_Temperature(file,2);
	int result1=MY_ASSERT_NOT_EQUAL(result);
  if(result1 == EXIT_FAILURE)
  {
    return EXIT_FAILURE;
  }
  return EXIT_SUCCESS;
}
/* --------------------------------------------------------------------------*/
/**
 * @Synopsis  :test functiion to test the temperature sensor readaing in Farenheit
 *
 * @Param file: File is used to allocate the path and bus to the I2C slave
 *
 * @Returns   :returns the exit status upon success or failure
 */
/* ----------------------------------------------------------------------------*/
int Test_Read_Temperature_Farenheit(int file)
{
	printf("\nTest Temperature in Farenheit:");
	I2C_init(&file,1);	
	int result = Read_Temperature(file,3);
	int result1=MY_ASSERT_NOT_EQUAL(result);
  if(result1 == EXIT_FAILURE)
  {
    return EXIT_FAILURE;
  }
  return EXIT_SUCCESS;
}
/* --------------------------------------------------------------------------*/
/**
 * @Synopsis  :test function to assert if the expected value is not equal to
 * the return value of the test function, and returns PASS if not equal to the 
 * EXIT_FAILURE or Fail if equal
 *
 * @Param result: the result contains the return value of the tested function 
 */
/* ----------------------------------------------------------------------------*/
int MY_ASSERT_NOT_EQUAL(int result)
{
	if(result != status)
	{
		printf("Pass!\n");
	}
	else
  {
    printf("Fail!");
  }
}

/* --------------------------------------------------------------------------*/
/**
 * @Synopsis  :test function to test the unit testing functions
 *
 * @Param result: the result contains the return value of the tested function 
 */
/* ----------------------------------------------------------------------------*/
int main_conversion(void)
{
	int file;

	Test_I2C_init_Conversion(file);
	
  Test_Read_Temperature_Celsius(file);
  Test_Read_Temperature_Kelvin(file);	
  Test_Read_Temperature_Farenheit(file);
	return 0;  
}
/*Unit Test to test various functions related to temperature conversion
 * Author: Harsimransingh Bindra & Yasir Aslam Shah
 * Advance Embedded System Design
 * Spring 2019
 * Definition: Test module to test various functionality for the unit conversion .Includes the following functions:
 * Functions:Test_I2C_init(int file),Test_Read_Temperature_Celsius(int file),Test_Read_Temperature_Kelvin(int file),
 * Test_Read_Temperature_Farenheit(int file),MY_ASSERT_NOT_EQUAL(int result)
 * */



#ifndef TEST_CONVERSION_H
#define TEST_CONVERSION_H


//Standard Library header
#include <errno.h>
#include <stdlib.h>
#include <stdio.h>

//User Defined Header
#include "temp.h"
#include "i2c.h"



//macros
#define status EXIT_FAILURE


//Function Defnition:
/* --------------------------------------------------------------------------*/
/**
 * @Synopsis  :Test function to test the I2C path and bus allocation to the slave(2)
 *
 * @Param file:File is used to allocate the I2C bus  and path to the slave
 *
 * @Returns   :returns exit status upon the success or failure of function
 */
/* ----------------------------------------------------------------------------*/
int Test_I2C_init_Conversion(int file);
/* --------------------------------------------------------------------------*/
/**
 * @Synopsis  :test functiion to test the temperature sensor readaing in Celsius
 *
 * @Param file: File is used to allocate the path and bus to the I2C slave
 *
 * @Returns   :returns the exit status upon success or failure
 */
/* ----------------------------------------------------------------------------*/
int Test_Read_Temperature_Celsius(int file);
/* --------------------------------------------------------------------------*/
/**
 * @Synopsis  :test functiion to test the temperature sensor readaing in Kelvin
 *
 * @Param file: File is used to allocate the path and bus to the I2C slave
 *
 * @Returns   :returns the exit status upon success or failure
 */
/* ----------------------------------------------------------------------------*/
int Test_Read_Temperature_Kelvin(int file);
/* --------------------------------------------------------------------------*/
/**
 * @Synopsis  :test functiion to test the temperature sensor readaing in Farenheit
 *
 * @Param file: File is used to allocate the path and bus to the I2C slave
 *
 * @Returns   :returns the exit status upon success or failure
 */
/* ----------------------------------------------------------------------------*/
int Test_Read_Temperature_Farenheit(int file);
/* --------------------------------------------------------------------------*/
/**
 * @Synopsis  :test function to assert if the expected value is not equal to
 * the return value of the test function, and returns PASS if not equal to the 
 * EXIT_FAILURE or Fail if equal
 *
 * @Param result: the result contains the return value of the tested function 
 */
/* ----------------------------------------------------------------------------*/
int MY_ASSERT_NOT_EQUAL(int result);

/* --------------------------------------------------------------------------*/
/**
 * @Synopsis  :test function to test the unit testing functions
 *
 * @Param result: the result contains the return value of the tested function 
 */
/* ----------------------------------------------------------------------------*/
int main_conversion(void);
#endif
/*Unit Test to test various functions related to Temperature
 * Author: Harsimransingh Bindra & Yasir Aslam Shah
 * Advance Embedded System Design
 * Spring 2019
 * Definition: Test module to test various functionality for teh temperarture sensor.Includes the following functions:
 * Functions: Test_I2C_init(),Test_Read_Sensor_Celsius(),Test_Read_Sensor_Kelvin(),Test_Read_Sensor_Farenheit(),Test_Read_TLow(),
Test_Read_THigh(int file),Test_Read_Resolution(),Test_Read_Fault_Bits(),Test_Clear_ShutDown(),Test_Set_ShutDown(),
Test_Set_EM(),Test_Set_Conversion(),Test_Write_Configuration(),MY_ASSERT_NOT_EQUAL()
 * */

#ifndef TEST_TEMP_H
#define TEST_TEMP_H
//Standard Header files
#include <errno.h>
#include <stdlib.h>
#include <stdio.h>

//User Defined Header files
#include "temperature.h"


//Macros
#define status EXIT_FAILURE



//function defnition:
/* --------------------------------------------------------------------------*/
/**
 * @Synopsis  :Test function to test the I2C path and bus allocation to the slave(1)
 *
 * @Param file:File is used to allocate the I2C bus  and path to the slave
 *
 * @Returns   :returns exit status upon the success or failure of function
 */
/* ----------------------------------------------------------------------------*/
int Test_I2C_init_Temp(int file);
/* --------------------------------------------------------------------------*/
/**
 * @Synopsis  :test functiion to test the temperature sensor readaing in Celsius
 *
 * @Param file: File is used to allocate the path and bus to the I2C slave
 *
 * @Returns   :returns the exit status upon success or failure
 */
/* ----------------------------------------------------------------------------*/
int Test_Read_Sensor_Celsius(int file);
/* --------------------------------------------------------------------------*/
/**
 * @Synopsis  :test functiion to test the temperature sensor readaing in Kelvin
 *
 * @Param file: File is used to allocate the path and bus to the I2C slave
 *
 * @Returns   :returns the exit status upon success or failure
 */
/* ----------------------------------------------------------------------------*/
int Test_Read_Sensor_Kelvin(int file);
/* --------------------------------------------------------------------------*/
/**
 * @Synopsis  :test functiion to test the temperature sensor readaing in Farenheit
 *
 * @Param file: File is used to allocate the path and bus to the I2C slave
 *
 * @Returns   :returns the exit status upon success or failure
 */
/* ----------------------------------------------------------------------------*/
int Test_Read_Sensor_Farenheit(int file);
/* --------------------------------------------------------------------------*/
/**
 * @Synopsis  :test function to read the Tlow value from the TMP102 Sensor,TLOW 
 * stands for thethreshold low value for the alert to occur
 *
 * @Param file: File is used to allocate the path and bus to the I2C slave
 *
 * @Returns   :returns exit status upon success or failure
 */
/* ----------------------------------------------------------------------------*/
int Test_Read_TLow(int file);
/* --------------------------------------------------------------------------*/
/**
 * @Synopsis  :test function to read the THigh value from the TMP102 Sensor,
 * THigh stands for thethreshold low value for the alert to occur
 *
 * @Param file: File is used to allocate the path and bus to the I2C slave
 *
 * @Returns   :returns exit status upon success or failure
 */
/* ----------------------------------------------------------------------------*/
int Test_Read_THigh(int file);
/* --------------------------------------------------------------------------*/
/**
 * @Synopsis  :test function to configure the sensor resolution  value from the 
 * TMP102 Sensor,the sensor has a 12 bit and a 13 bit resolution
 *
 * @Param file: File is used to allocate the path and bus to the I2C slave
 *
 * @Returns   :returns exit status upon success or failure
 */
/* ----------------------------------------------------------------------------*/
int Test_Read_Resolution(int file);
/* --------------------------------------------------------------------------*/
/**
 * @Synopsis  :test function to configure the fault bits of sensor TMP102,a consecutive 
 * fault options of 1,2,4 and 6 are avaialble for the system to trigger the alert
 *
 * @Param file: File is used to allocate the path and bus to the I2C slave
 *
 * @Returns   :returns exit status upon success or failure
 */
/* ----------------------------------------------------------------------------*/
int Test_Read_Fault_Bits(int file);
/* --------------------------------------------------------------------------*/
/**
 * @Synopsis  :test function to configure the shutdown feature for the temperature
 * sensor, setting the shutdown bit enables the shutdown mode
 *
 * @Param file: File is used to allocate the path and bus to the I2C slave
 *
 * @Returns   :returns exit status upon success or failure
 */
/* ----------------------------------------------------------------------------*/
int Test_Clear_ShutDown(int file);
/* --------------------------------------------------------------------------*/
/**
 * @Synopsis  :test function to configure the shutdown feature for the temperature
 * sensor, clearing the shutdown bit disables the shutdown mode
 *
 * @Param file: File is used to allocate the path and bus to the I2C slave
 *
 * @Returns   :returns exit status upon success or failure
 */
/* ----------------------------------------------------------------------------*/
int Test_Set_ShutDown(int file);
/* --------------------------------------------------------------------------*/
/**
 * @Synopsis  :test function to configure the Extended Mode, extended mode allows 13 bit 
 * temperature reading allowing to read temperature above 128C
 *
 * @Param file: File is used to allocate the path and bus to the I2C slave
 *
 * @Returns   :returns exit status upon success or failure
 */
/* ----------------------------------------------------------------------------*/
int Test_Set_EM(int file);
/* --------------------------------------------------------------------------*/
/**
 * @Synopsis  :test function to configure the conversion rate for the sensor, 
 * conversion rate of 1Hz,4Hz and 8Hz are avaialable with 4Hz as default
 *
 * @Param file: File is used to allocate the path and bus to the I2C slave
 *
 * @Returns   :returns exit status upon success or failure
 */
/* ----------------------------------------------------------------------------*/
int Test_Set_Conversion(int file);
/* --------------------------------------------------------------------------*/
/**
 * @Synopsis  :test function to configure the write configuration register to 
 * enable and disable various features in TMP 102
 *
 * @Param file: File is used to allocate the path and bus to the I2C slave
 *
 * @Returns   :returns exit status upon success or failure
 */
/* ----------------------------------------------------------------------------*/
int Test_Write_Configuration(int file);
/* --------------------------------------------------------------------------*/
/**
 * @Synopsis  :test function to assert if the expected value is not equal to
 * the return value of the test function, and returns PASS if not equal to the 
 * EXIT_FAILURE or Fail if equal
 *
 * @Param result: the result contains the return value of the tested function 
 */
/* ----------------------------------------------------------------------------*/
//int MY_ASSERT_NOT_EQUAL(int result);
/* --------------------------------------------------------------------------*/
/**
 * @Synopsis  :test function to run all the test functions for temperature sensor
 *
 * @Param result: the result contains the return value of the tested function 
 */
/* ----------------------------------------------------------------------------*/
int main_temp(void);
#endif
/*Unit Test to test various functions related to Light Sensor APDS 9301
 * Author: Harsimransingh Bindra & Yasir Aslam Shah
 * Advance Embedded System Design
 * Spring 2019
 * Definition: Test module to test various functionality for the Light sensor.Includes the following functions:
 * Functions:MY_ASSERT_NOT_EQUAL(),Test_I2C_init(),Test_Turn_on_light_sensor(),Test_Check_PowerUp(),Test_Read_Sensor_ID(),Test_Light_Sensor(),Test_Write_Interrupt(),Test_Read_Interrupt(),int Test_Status()
 * */

#ifndef TEST_LIGHT_H
#define TEST_LIGHT_H


//Standard Header Files
#include <errno.h>
#include <stdlib.h>
#include <stdio.h>

//User Defined Header Files
#include "light.h"
//macros
#define status EXIT_FAILURE



//Function Defnition:
/* --------------------------------------------------------------------------*/
/**
 * @Synopsis  :Test function to test the I2C path and bus allocation to the slave(2)
 *
 * @Param file:File is used to allocate the I2C bus  and path to the slave
 *
 * @Returns   :returns exit status upon the success or failure of function
 */
/* ----------------------------------------------------------------------------*/
int Test_I2C_init_Light(int file);
/* --------------------------------------------------------------------------*/
/**
 * @Synopsis  :Test function to test the powering up of Sensor by writing to the 
 * control register
 *
 * @Param file:File is used to allocate the I2C bus  and path to the slave
 *
 * @Returns   :returns exit status upon the success or failure of function
 */
/* ----------------------------------------------------------------------------*/
int Test_Turn_on_light_sensor(int file);
/* --------------------------------------------------------------------------*/
/**
 * @Synopsis  :Test function to check if the powering up the sensor is successfull
 * or not 
 *
 * @Param file:File is used to allocate the I2C bus  and path to the slave
 *
 * @Returns   :returns exit status upon the success or failure of function
 */
/* ----------------------------------------------------------------------------*/
int Test_Check_PowerUp(int file);
/* --------------------------------------------------------------------------*/
/**
 * @Synopsis  :Test function to read the sensor id of Light APDS 9301 to ensure the
 * I2C is working or not
 *
 * @Param file:File is used to allocate the I2C bus  and path to the slave
 *
 * @Returns   :returns exit status upon the success or failure of function
 */
/* ----------------------------------------------------------------------------*/
int Test_Read_Sensor_ID(int file,uint8_t SensorID);
/* --------------------------------------------------------------------------*/
/**
 * @Synopsis  :Test function to test the Light sensor and ensure if the values 
 * returned are correct and changes as per a change in ambient light around the
 * sensor
 *
 * @Param file:File is used to allocate the I2C bus  and path to the slave
 *
 * @Returns   :returns exit status upon the success or failure of function
 */
/* ----------------------------------------------------------------------------*/
int Test_Light_Sensor(int file);
/* --------------------------------------------------------------------------*/
/**
 * @Synopsis  :Test function to test the Light sensor by reading from the 16bit 
 * channels from the sensor
 *
 * @Param file:File is used to allocate the I2C bus  and path to the slave
 *
 * @Returns   :returns exit status upon the success or failure of function
 */
/* ----------------------------------------------------------------------------*/
int Test_Read_Data(int file);
/* --------------------------------------------------------------------------*/
/**
 * @Synopsis  :Test function to configure the interrupt by writing the High High, 
 * High Low, Low High and Low Low to the Sensor.
 *
 * @Param file:File is used to allocate the I2C bus  and path to the slave
 * @Param SensorID: is a paramameter to select the Light Sensor as SensorID:2
 *
 * @Returns   :returns exit status upon the success or failure of function
 */
/* ----------------------------------------------------------------------------*/
int Test_Write_Interrupt(int file, uint8_t SensorID);
/* --------------------------------------------------------------------------*/
/**
 * @Synopsis  :Test function to check if the values returned after writing the 
 * interrupt values are returned to be same after reading them back
 *
 * @Param file:File is used to allocate the I2C bus  and path to the slave
 *
 * @Returns   :returns exit status upon the success or failure of function
 */
/* ----------------------------------------------------------------------------*/
int Test_Read_Interrupt(int file);
/* --------------------------------------------------------------------------*/
/**
 * @Synopsis  :Test function to check the state of the system to be DARK or LIGHT 
 * based on the LUX values
 *
 * @Param file:File is used to allocate the I2C bus  and path to the slave
 *
 * @Returns   :returns exit status upon the success or failure of function
 */
/* ----------------------------------------------------------------------------*/
int Test_Status(int file);
/* --------------------------------------------------------------------------*/
/**
 * @Synopsis  :test function to assert if the expected value is not equal to
 * the return value of the test function, and returns PASS if not equal to the 
 * EXIT_FAILURE or Fail if equal
 *
 * @Param result: the result contains the return value of the tested function 
 */
/* ----------------------------------------------------------------------------*/
//int MY_ASSERT_NOT_EQUAL(int result);
/* --------------------------------------------------------------------------*/
/**
 * @Synopsis  :test function to run all the test functions for the light sensor
 *
 * @Param result: the result contains the return value of the tested function 
 */
/* ----------------------------------------------------------------------------*/
int main_light(void);
#endif
/* -.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.
* File Name : socket.h
* Creation Date : 20-03-2019
* Last Modified : Wed 20 March 2019 00:08:56 PM MDT
* Created By : Harsimransingh
* Description: header file to use sockets for IPC communication
* Functions:
*           socket_function() to handle external communication 
* References:
*           https://www.geeksforgeeks.org/socket-programming-cc/
*           https://www.csd.uoc.gr/~hy556/material/tutorials/cs556-3rd-tutorial.pdf
*           https://github.com/harsimran2421/AESD-5013-002-/tree/master/Assignment-4/sockets
_._._._._._._._._._._._._._._._._._._._._.*/



#ifndef __SOCKET_H
#define __SOCKET_H

#include<stdio.h>
#include<stdlib.h>
#include<stdint.h>
#include<string.h>
#include<stdbool.h>
#include<signal.h>
#include<fcntl.h>
#include<unistd.h>
#include<sys/stat.h>
#include<sys/types.h>
#include<sys/socket.h>
#include<sys/wait.h>
#include<netinet/in.h>
#include<arpa/inet.h>
#include<netdb.h>

#define MAXBUFSIZE 200
#define SEND_BUFFER_SIZE 512
#define RECIEVE_BUFFER_SIZE 512
#define PORT_NUMBER 9000


/**
 * @brief 
 * socket_function() is a function called when socket pthread is created. It connects with other processes using SOCK STREAM(TCP) and provides instantaneous temperature or light values depending on what is requested from the external process.
 *  
 * @param arg
 *
 * @return void since it is a function linked to a pthread
 */
void *socket_function(void *arg);

#endif
/* -.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.
* File Name : logger.h
* Creation Date : 19-03-2019
* Last Modified : Sun 31 March 2019 00:10:11 PM MDT
* Created By : Harsimransingh and Yasir Shah
* Description: header file for logger function declaration and structure declarations
* 
* Functions:
*           logging_thread() linked to logger pthread task
*           logging_function() to log messages in a common log file
*           timer_setup() to set timer attributes for heartbeat
* References:
_._._._._._._._._._._._._._._._._._._._._.*/

#ifndef _LOGGER_H
#define _LOGGER_H

/*standard headers*/
#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <fcntl.h> 
#include <errno.h>

/*system headers*/
#include <signal.h>
#include <sys/time.h>
#include <sys/types.h>
#include <sys/syscall.h>
#include <sys/socket.h>
#include <sys/stat.h>

/*POSIX thread*/
#include <pthread.h>  

/*IPC headers*/
#include <netinet/in.h> 
#include <mqueue.h>
#include <netdb.h>

/*I2C headers*/
#include <linux/i2c-dev.h>
#include <sys/ioctl.h>

/*user libraries*/
#include "user_led.h"

#ifndef DEBUG
#define perror(...) 
#endif

pthread_mutex_t bus_lock, heartbeat_mutex, logger_mutex;
pthread_cond_t temp_thread_cond,light_thread_cond, logger_thread_cond;
int exit_flag;
int light_flag;
int temperature_flag;

/*structure to store thread attributes*/
typedef struct thread_content{

    pthread_t tid;         // the thread identifier
    char* log_file;

}thread_struct;

/*structure to store log messages*/
typedef struct message_struct
{
  char thread_name[20];
  char level[6];
  char state[6];
  float sensor_value;
  char unit;

}msg_struct;


/* -------------------------------*/
/**
 * @Synopsis linked to logger pthread task used for synchronized logging
 *
 * @Param arg to pass arguement to pthread 
 *
 * @Returns void pointer is returned
 */
/* ---------------------------------*/
void *logging_thread(void *arg);

/* -------------------------------*/
/**
 * @Synopsis to log recieved message to a common file
 *
 * @Param parent_id - get parent ID process
 * @Param pthread_id - ID of the pthread sending the message
 * @Param thread_id - thread ID of the logging message
 * @Param file_name - file where the message should be logged
 * @Param ip_str  - user message
 * @Param msg - msg structure containing data
 */
/* ---------------------------------*/
void logging_function(int parent_id, int pthread_id, int thread_id, char *file_name,char* ip_str,msg_struct *msg);


/* -------------------------------*/
/**
 * @Synopsis to setup the heartbeat timer attrbutes
 *
 * @Param second_value - seconds interval value
 * @Param nanosec_value - nanosec interval value
 *
 * @Returns the timerspec struct with the required attributes set
 */
/* ---------------------------------*/
struct timespec timer_setup(uint32_t second_value, uint32_t nanosec_value);

#endif
/*Unit Test to test various unit tests
 * Author: Harsimransingh Bindra & Yasir Aslam Shah
 * Advance Embedded System Design
 * Spring 2019
 * Definition: Test module to test various functionality for the unit conversion .Includes the following functions:
 * Functions: test_main()
 * */

#ifndef _TEST_H
#define _TEST_H
//user defined files
#include "test_light.h"
#include "test_temp.h"
#include "test_conversion.h"

/* --------------------------------------------------------------------------*/
/**
 * @Synopsis  :Test main function , testing light, temp and conversion unit test
 *
 * @Returns   :returns EXIT status based on success or failure
 */
/* ----------------------------------------------------------------------------*/
//int test_main(void);
#endif
/* -.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.
* File Name : initial_test.h
* Creation Date : 31-03-2019
* Last Modified : Sun 31 March 2019 00:07:10 PM MDT
* Created By : Harsimransingh and Yasir Shah
* Description: header file to run inital tests for sensors
* Functions:
*           intial_test() to test all sensors before creating threads
* References:
_._._._._._._._._._._._._._._._._._._._._.*/


#ifndef _INTIAL_TEST_H
#define _INTIAL_TEST_H

/* -------------------------------*/
/**
 * @Synopsis this function calls the temperature test and light test functions to check if there are functional before moving forward with creating the threads 
 *
 * @Param filename parameter provides the log file name
 *
 * @Returns exit status based on success or failure
 */
/* ---------------------------------*/
int intial_test(char *filename);

#endif
/* -.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.
* File Name : led_control.h
* Creation Date : 29-03-2019
* Last Modified : Sun 31 March 2019 00:10:12 PM MDT
* Created By : Harsimransingh and Yasir Shah
* Description: header file to control on board leds
* Functions:
*           led_control() to turn on board leds on or off based on the inputs
* References:
_._._._._._._._._._._._._._._._._._._._._.*/

#ifndef __USER_LED_H
#define __USER_LED_H

/*standard libraries*/
#include <stdio.h>
#include <stdlib.h>

/*Macros to select leds*/
#define BLUE  1
#define RED   2
#define GREEN 3

/*Macros for led status*/
#define ON  1
#define OFF 0

/* -------------------------------*/
/**
 * @Synopsis function to control the on board leds. Pin 53,54 and 55 are used. 
 *
 * @Param led_color to select the led number
 * @Param status to take input from user to turn led on or off
 */
/* ---------------------------------*/
void led_control(int led_color, int status);

#endif
/* -.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.
* File Name : light.h
* Creation Date : 20-03-2019
* Last Modified : Wed 31 March 2019 00:07:26 PM MDT
* Created By : Harsimransingh and Yasir Shah
* Description: header file to contatainging function declaration for light sensors
* 
* Functions:
*           - Light_main() function is first initializes the I2C bus then calls the Read_Data function. 
*           - Read_Data() it calculates the lux value based on channel 1 and channel 2 values depending on the datasheet
*           - Read_Light_Sensor() it calculates the lux value based on channel 1 and channel 2 values depending on the datasheet 
*           - Turn_on_Light_sensor() turns the sensor on
*           - Check_PowerUp() to test if it successfully powers up the sensor
*           - light_function() light pthread spawned calls this function
*           - light_handler() light timer handler which logs the light value periodically by addding new light value to the temp queue.
* 
* References:
*           -https://www.broadcom.com/products/optical-sensors/ambient-light-photo-sensors/apds-9301
*           -https://learn.sparkfun.com/tutorials/apds-9301-sensor-hookup-guide/all         
_._._._._._._._._._._._._._._._._._._._._.*/

#ifndef LIGHT_H
#define LIGH_H

/*standard libraries*/
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <math.h>
#include <fcntl.h>
#include <sys/ioctl.h>
#include <linux/i2c-dev.h>
#include <unistd.h>

/*used defined libraries*/
#include "i2c.h"
#include "logger.h"
#include "user_led.h"

/*macros for Light Sensor APDS 9301*/
#define Power_Up 0x03
#define Command_Control 0x80
#define Command_Reg 0x00
#define Timing_Reg 0x01
#define Data_Low0 0x0c
#define Data_High0 0x0D 
#define Data_Low1 0x0E
#define Data_High1 0x0F
#define Sensor_ID 0x0A
#define Set_Gain 0x12
#define Interrupt_Control_reg_Disable 0x06
#define Interrupt_Control_reg_Enable 0x06
#define Threshold_LL 0x02
#define Threshold_LH 0x03
#define Threshold_HL 0x04
#define Threshold_HH 0x05
#define LIGHT_THRESHOLD 20
/*global variables*/
int file;
float Lux_Value;

/*functions*/

/* -------------------------------*/
/**
 * @Synopsis init function for light sensor to initialise and read
 *
 * @Param light_value to return the light value to the calling function
 *
 * @Returns exit status to indicate whether light value was read succcessfully from the sensor or an Error
 */
/* ---------------------------------*/
int Light_main(float *light_value);

/* -------------------------------*/
/**
 * @Synopsis read function to read LUX Low and High Values 
 *
 * @Param file  to provide path for i2c bus
 * @Param flag  to select data channels -CH0(16 bits) CH1(16 bits)
 *
 * @Returns the light lux value
 */
/* ---------------------------------*/
uint16_t Read_Data(int file, int flag);

//function to read lux value
/* -------------------------------*/
/**
 * @Synopsis it calculates the lux value based on channel 1 and channel 2 values depending on the datasheet
 *
 * @Param file  to provide path for i2c bus 
 * @Param light_value to return the light value to the calling function
 *
 * @Returns returns the lux value based on datasheet calculation
 */
/* ---------------------------------*/
int Read_Light_Sensor(int file, float *light_value);

//function to check sensor is working by power up

/* -------------------------------*/
/**
 * @Synopsis firstly is powers up the light sensor then sets the gain for the sensor. Next the intergration time is set to 402ms based on Set_Gain macro. We change the control register value of the light sensor in this function
 *
 * @Param file to provide path for i2c bus
 *
 * @Returns exit status based on success or failure
 */
/* ---------------------------------*/
int Turn_on_Light_sensor(int file);

//function to see if power up is working
/* -------------------------------*/
/**
 * @Synopsis to test whether the control register was changed successfully or not
 *
 * @Param file to provide path for i2c bus
 *
 * @Returns exit status based on success or failure
 */
/* ---------------------------------*/
int Check_PowerUp(int file);

/* -------------------------------*/
/**
 * @Synopsis light pthread spawned calls this function which initalises the light queue, intializes the timer parameters and starts a timer which logs light value periodically
 *
 * @Param arg to pass any arguements to this function
 *
 * @Returns void as linked to pthread
 */
/* ---------------------------------*/
void *light_function(void *arg);

/* -------------------------------*/
/**
 * @Synopsis light timer handler which logs the light value periodically by adding new light value to the light queue. 
 *
 * @Param sv
 */
/* ---------------------------------*/
void light_handler(union sigval sv);


/* -------------------------------*/
/**
 * @Synopsis Read_Sensor_Id() reads the sensor ID connected to the I2C bus
 *
 * @Param file to provide path for i2c bus
 * @Param data it returns the sensor ID read.
 *
 * @Returns exit status based on success or failure
 */
/* ---------------------------------*/
int Read_Sensor_ID(int file,uint8_t *data);

/* -------------------------------*/
/**
 * @Synopsis To check if the interrupt registers are written successfully or not
 *
 * @Param file to provide path for i2c bus
 *
 * @Returns exit status based on success or failure
 */
/* ---------------------------------*/
int Read_Interrupt(int file);

/* -------------------------------*/
/**
 * @Synopsis To write the interrupt register of the light sensor
 *
 * @Param file to provide path for i2c bus
 * @Param in_value the value to be written on the interrupt register
 *
 * @Returns exit status based on success or failure
 */
/* ---------------------------------*/
int Write_Interrupt(int file, uint8_t *in_value);  

/* -------------------------------*/
/**
 * @Synopsis to disable the interrupts on the sensor
 *
 * @Param file to provide path for i2c bus
 *
 * @Returns exit status based on success or failure
 */
/* ---------------------------------*/
int Disable_Interrupt_Control_Register(int file);

/* -------------------------------*/
/**
 * @Synopsis to enable the interrupts for the light sensor
 *
 * @Param file to provide path for i2c bus
 *
 * @Returns exit status based on success or failure
 */
/* ---------------------------------*/
int Enable_Interrupt_Control_Register(int file);


/* -------------------------------*/
/**
 * @Synopsis check the current state of based on Lux values whether it is currently dark or light
 *
 * @Param file to provide path for i2c bus
 * @Param Lux input light value 
 *
 * @Returns exit status based on success or failure
 */
/* ---------------------------------*/
void light_state(float light_value, msg_struct *msg);

int light_test();
#endif
/* -.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.-.
* File Name : temperature.h
* Creation Date : 21-03-2019
* Last Modified : Wed 31 March 2019 00:02:56 PM MDT
* Created By : Harsimransingh and Yasir Shah
* Description: header file to contatainging function declaration for temperature
* 
* Functions:
*           -temp_main() function is first initializes the I2C bus then calls the read_temperature function. 
*           -Read_Temperature() read function to read data from TMA102 sensor in C,K,F
*           -temperature_function() temperature pthread spawned calls this function which initalises the temperature queue intializes the timer parameters and starts a timer which logs temperature value periodically
*           -temperature_handler() Temperature timer handler which logs the temperature periodically by addding new temperature value to the temp queue.
*           -temp_test() used for intial testing of the sensor
*           -temp_state() for knowing the current state
*           -Write_pointer_reg()
*           -Read_Tlow()
*           -Read_Thigh()
*           -Read_Resolution()
*           -Read_Fault_Bits()
*           -Set_ShutDown()
*           -Clear_ShutDown()
*           -Set_EM()
*           -Set_Conversion()
*           -Write_Configuration()
* References:
*           -http://www.ti.com/lit/ds/symlink/tmp102.pdf
*           -https://www.sparkfun.com/products/13314  
*           
_._._._._._._._._._._._._._._._._._._._._.*/




#ifndef TEMP_H
#define TEMP_H
/*Standard c libraries*/
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <errno.h>
#include <sys/ioctl.h>
#include <fcntl.h>
#include <unistd.h>

/*User defined libraries*/
#include "logger.h"
#include "i2c.h"

/*macros for temperature sensor*/
#define TMPSensor_Register 0x00
#define Minus_Correction 0xF800
#define Celsius 0.0625
#define KELVIN 273.5
#define FAREN 1.8
#define HEIT 32
#define TMPSensor_Conversion_8 0xC0
#define TMPSensor_Conversion_4 0x10
#define TMPSensor_Conversion_1 0x40
#define EM_Set 0x10
#define ShutDown_Set 0x6100
#define ShutDown_Clear 0x6000
#define Fault_Bits_4 0x7800
#define Fault_Bits_1 0x6000
#define Resolution 0x6000
#define TMPSensor_Configuration 0x01
#define TMPSensor_TLow 0x02
#define TMPSensor_THigh 0x03
#define Mask 0b00010000
#define KELVIN_THRESHOLD 298
#define FARHENIET_THRESHOLD 77
#define CELSIUS_THRESHOLD 25
/*  1 - celsius
 *  2 - Kelvin
 *  3 - Farheniet
 * */
#define UNIT 1
/*global variable*/
int file;

/* -------------------------------*/
/**
 * @Synopsis temp_main() function is first initializes the I2C bus then calls the read_temperature function.
 *
 * @Param temp_value  used to return the temperature value to the callin function
 * @Param unit  used to indicate which is required by the calling function(Celcius, Kelvin or Farheniet)
 *
 * @Returns Exit status whether the temperature calculation was a success or not
 */
/* ---------------------------------*/
int temp_main(float *temp_value,int unit);

/* -------------------------------*/
/**
 * @Synopsis  read function to read data from TMA102 sensor in C,K,F
 *
 * @Param file 
 * @Param unit used to indicate which is required by the calling function(Celcius, Kelvin or Farheniet)
 * @Param temp_value used to return the temperature value to the callin function
 *
 * @Returns Exit status whether the temperature calculation was a success or not
 */
/* ---------------------------------*/
int Read_Temperature(int file,int unit, float *temp_value);

/* -------------------------------*/
/**
 * @Synopsis temperature pthread spawned calls this function which initalises the temperature queue intializes the timer parameters and starts a timer which logs temperature value periodically
 *
 * @Param arg Nothing is passed to this function
 *
 * @Returns void as linked to phtread
 */
/* ---------------------------------*/
void *temperature_function(void *arg);


/* -------------------------------*/
/**
 * @Synopsis Temperature timer handler which logs the temperature periodically by addding new temperature value to the temp queue.
 *
 * @Param sv  used to pass the log file name.
 */
/* ---------------------------------*/
void temperature_handler(union sigval sv);

/* -------------------------------*/
/**
 * @Synopsis this is called during the startup to test whether the temperature sensor is functional or not
 *
 * @Returns returns exit status based on success or failure
 */
/* ---------------------------------*/
int temp_test();

/* -------------------------------*/
/**
 * @Synopsis this function checks to current state based on temperature threshold values
 *
 * @Param temp_value - provides current temperature value
 * @Param msg - msg structure where state needs to be stored
 * @Param unit - temperature unit
 */
/* ---------------------------------*/
void temp_state(float temp_value, msg_struct *msg, int unit);

/* -------------------------------*/
/**
 * @Synopsis used to write the pointer register of TMP 102 sensor
 *
 * @Param file  to provide path for i2c bus
 * @Param value provides value to be written in the register
 *
 * @Returns exit status based on success or failure 
 */
/* ---------------------------------*/
int Write_pointer_reg(int file, uint8_t value);

/* -------------------------------*/
/**
 * @Synopsis reads the lower threshold value of TMP 102 sensor
 *
 * @Param file to provide path for i2c bus
 *
 * @Returns exit status based on success or failure
 */
/* ---------------------------------*/
int Read_TLow(int file);

/* -------------------------------*/
/**
 * @Synopsis reads the highe threshold value of TMP 102 sensor
 *
 * @Param file  to provide path for i2c bus
 *
 * @Returns exit status based on success or failure
 */
/* ---------------------------------*/
int Read_THigh(int file);

/* -------------------------------*/
/**
 * @Synopsis reads the current resolution on which the TMP 102 sensor is set
 *
 * @Param file  to provide path for i2c bus
 *
 * @Returns exit status based on success or failure
 */
/* ---------------------------------*/
int Read_Resolution(int file);

/* -------------------------------*/
/**
 * @Synopsis reads which fault bits are set currrently.
 *
 * @Param file to provide path for i2c bus
 *
 * @Returns exit status based on success or failure
 */
/* ---------------------------------*/
int Read_Fault_Bits(int file);

/* -------------------------------*/
/**
 * @Synopsis it sets the shutdown bit to reduce current consumption
 *
 * @Param file to provide path for i2c bus
 *
 * @Returns exit status based on success or failure
 */
/* ---------------------------------*/
int Set_ShutDown(int file);

/* -------------------------------*/
/**
 * @Synopsis clears the shutdown bit to make the sensor completely functional
 *
 * @Param file  to provide path for i2c bus
 *
 * @Returns exit status based on success or failure
 */
/* ---------------------------------*/
int Clear_ShutDown(int file);

/* -------------------------------*/
/**
 * @Synopsis`it changes the resolution of the sensor from 12 bits to 13 bits if wider temperature range is required
 *
 * @Param file to provide path for i2c bus
 *
 * @Returns exit status based on success or failure
 */
/* ---------------------------------*/
int Set_EM(int file);

/* -------------------------------*/
/**
 * @Synopsis it changes the read frequency of sensor between 1,4 and 8 Hz
 *
 * @Param file to provide path for i2c bus
 *
 * @Returns exit status based on success or failure
 */
/* ---------------------------------*/
int Set_Conversion(int file);

/* -------------------------------*/
/**
 * @Synopsis it writes the configuration register to access different sensor modes
 *
 * @Param file  to provide path for i2c bus
 *
 * @Returns exit status based on success or failure
 */
/* ---------------------------------*/
int Write_Configuration(int file,int val);

#endif
/*Name:i2c.h file*/
/*Author:*/
/* Project 1*/
/*Description:This header file contains includes,
and function defnition for i2c for project1*/

#ifndef I2C_H
#define I2C_H

#include "logger.h"

//macros
#define Temper 1
#define Light 2


//function defnition 
//init function to define i2c path and
//allocate the i2c bus 
/* -------------------------------*/
/**
 * @Synopsis  
 *
 * @Param file
 * @Param sensor
 *
 * @Returns   
 */
/* ---------------------------------*/
int I2C_init(int *file, uint8_t sensor);

//function to write control registers for 
//APDS Sensor
uint8_t write_control(int file, uint8_t data);

//function to write timing registers for 
//APDS Sensor
uint8_t write_timing(int file, uint8_t data);

//conversion function to deal with 
//UNITS for temperature from TMA 102
float Temp_Conversion(float temp, int unit);
//Read I2C data one single byte 
int I2C_Read_Byte_Data(int file , uint8_t *data);
//Read I2C data one single word 
int I2C_Read_Word(int file , uint8_t *data);
//Write I2C data one single byte
int I2C_Write_Byte(int file , uint8_t data);
//Write I2C data one single word
int I2C_Write_Word(int file , uint8_t *data);
//Write I2C data with 16bit data
int I2C_Write_Bytes(int file , uint16_t * data);
#endif
/*Unit Test to test various functions related to temperature conversion
 * Author: Harsimransingh Bindra & Yasir Aslam Shah
 * Advance Embedded System Design
 * Spring 2019
 * Definition: Test module to test various functionality for the unit conversion .Includes the following functions:
 * Functions:Test_I2C_init(int file),Test_Read_Temperature_Celsius(int file),Test_Read_Temperature_Kelvin(int file),
 * Test_Read_Temperature_Farenheit(int file),MY_ASSERT_NOT_EQUAL(int result)
 * */



#ifndef TEST_CONVERSION_H
#define TEST_CONVERSION_H


//Standard Library header
#include <errno.h>
#include <stdlib.h>
#include <stdio.h>

//User Defined Header
#include "temperature.h"
#include "i2c.h"



//macros
#define status EXIT_FAILURE


//Function Defnition:
/* --------------------------------------------------------------------------*/
/**
 * @Synopsis  :Test function to test the I2C path and bus allocation to the slave(2)
 *
 * @Param file:File is used to allocate the I2C bus  and path to the slave
 *
 * @Returns   :returns exit status upon the success or failure of function
 */
/* ----------------------------------------------------------------------------*/
int Test_I2C_init_Conversion(int file);
/* --------------------------------------------------------------------------*/
/**
 * @Synopsis  :test functiion to test the temperature sensor readaing in Celsius
 *
 * @Param file: File is used to allocate the path and bus to the I2C slave
 *
 * @Returns   :returns the exit status upon success or failure
 */
/* ----------------------------------------------------------------------------*/
int Test_Read_Temperature_Celsius(int file);
/* --------------------------------------------------------------------------*/
/**
 * @Synopsis  :test functiion to test the temperature sensor readaing in Kelvin
 *
 * @Param file: File is used to allocate the path and bus to the I2C slave
 *
 * @Returns   :returns the exit status upon success or failure
 */
/* ----------------------------------------------------------------------------*/
int Test_Read_Temperature_Kelvin(int file);
/* --------------------------------------------------------------------------*/
/**
 * @Synopsis  :test functiion to test the temperature sensor readaing in Farenheit
 *
 * @Param file: File is used to allocate the path and bus to the I2C slave
 *
 * @Returns   :returns the exit status upon success or failure
 */
/* ----------------------------------------------------------------------------*/
int Test_Read_Temperature_Farenheit(int file);
/* --------------------------------------------------------------------------*/
/**
 * @Synopsis  :test function to assert if the expected value is not equal to
 * the return value of the test function, and returns PASS if not equal to the 
 * EXIT_FAILURE or Fail if equal
 *
 * @Param result: the result contains the return value of the tested function 
 */
/* ----------------------------------------------------------------------------*/
int MY_ASSERT_NOT_EQUAL(int result);

/* --------------------------------------------------------------------------*/
/**
 * @Synopsis  :test function to test the unit testing functions
 *
 * @Param result: the result contains the return value of the tested function 
 */
/* ----------------------------------------------------------------------------*/
int main_conversion(void);
#endif
